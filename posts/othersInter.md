---
title: '其他人面试总结 学习'
date: '2023-08-15'
---
[toc]  

![images _2_](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/images_(2).jpg)

**全篇字数6W+，助你成为面试候选人中最靓的仔**

本人历经一个月的鏖战，终于斩获了自己心仪的offer，以下是在面试过程中获取的一些经验，希望可以帮到大家，也省去大家搜索资料的过程，如果答案之中有链接的话，最好点进去大致看下。  

> 注意：面试找工作是一个**双向奔赴**的过程，在面试过程中要做到**不卑不亢**  

# 个人介绍&薪资  

## 个人介绍  

这个环节非常重要，可以让面试官了解一下你的大致情况，时间控制在1~3min即可，具体可以从以下几个方面介绍：  

* 个人的基本情况（姓名、毕业院校、专业等）
* 工作相关（日常主要负责哪些项目开发、主要使用到哪些技术栈，参与过哪些项目的研发等）  
* 生活相关（性格、兴趣爱好、是否容易相处、学习能力、适应能力等）  
* 其他（可以介绍下自己感兴趣的一些东西，比如：技术，封装过一些类库等）    

示例(可以自己临场发挥)：   

我叫xxx，毕业于xx大学中的xx专业，目前有n年的工作经验。在工作中主要负责xxx系统的日常开发和维护，除了主要负责xxx系统外，也参与过yyy系统的开发，包括也会封装一些常用的组件和方法等，也会做一些后端中间层，包括API接口的开发工作，其中主要使用到的技术找是：例如：Vue、React、Jquery、Zepto、uniApp、Node等等（自由发挥，丰富下自己的语句），在生活中，我是一个乐于助人、幽默开朗、诚实守信、乐观向上、严于律己的一个人，跟同事相处的非常融洽和谐(自己根据[搜索](http://www.360doc.com/content/16/0623/16/34147982_570159625.shtml)内容整理下)，除了日常工作之外，我会看一些书籍(非技术性相关的也可以)来丰富自己的知识、扩展自己的视野，并且经常记一些笔记和写一些技术博客，包括也会自己搭一些框架，做一些自己的项目等。。。这是我个人的一些基本情况，谢谢。

## 薪资  
**只谈情怀不谈钱的都是耍流氓**  

当面试官和HR问你期望薪资或者年薪的时候，先别那么着急回答，在回答之前需要了解他们公司薪资结构的基本情况，你需要反问他们  

问题如下：  
> * 福利：五险一金(公积金按总薪资的多少缴纳，缴纳比例是多少)
> * 月度：例如：80%基本工资+20%绩效工资+餐补+话补+车补等等
> * 年度：12月基本薪资+n月KPI奖金+m月年终奖金（m和n不一定都有，而且多数企业只讲个范围）
> * 涨薪：一年两次调薪考核，时间是每年的4月和10月。但是主要依据KPI完成情况，不保证人人普调。
 > * 期权、股票：如有会详细说明计划。说会有但没有明确计划的，都是忽悠。    

之后再给出你期望的薪资  


如果你想了解的详细点，可以从下面几个方面回答：  

> * 试用期：多久，按正式工资的多少发放  
> * 晋升制度：每年2次晋升考核，时间是每年的1月和7月。自己申请，直系leader申报，考核委员会统一面试。
> * 培训制度：X级以上员工每年享受XXXX元额度及XX天时间的带薪培训计划，课程由公司指定也可自选。
> * 休假制度：试用期年假3天，第一年年假7天，第二年10天，第三年开始每年+5天。产假/陪产假XX天，婚假/丧假XX天，事假/病假时工资计算标准。
> * 考勤制度：标准工作时间早9点到晚6点，指纹考勤，弹性工作制，早晚考勤时间达到8小时即可。最晚上班时间9点半，超出算迟到。3次以内罚款，3~10次公司通报，10次以上公司有权利解聘。
> * 加班/值班制度：加班需要申请，直系leader审批。工作日加班积累小时数可调休，周末加班双薪，节假日三薪。工作日加班到X点之后，打车费/晚餐费可在X额度内报销。值班算/不算加班。
> * 其他福利：免费零食、公司包场员工免费的体育活动、固定组织的团体带薪旅游等。



# 技术相关  

俗话说：是骡子是马拉出来溜溜，想要获取一份好工作，只会吹是不行的，必须要有**真才实学**，技术牛皮的话，你想咋样咋样。    

虽然说在工作中主要负责的是前端这一块，但是有些后端的知识也必须了解，这样才能在工作中更加的得心应手，包括前端面试的时候不一定只问前端相关的知识。

以下罗列了一些常见的问题，包括但不限于：    

* HTTP(网络)
* HTML(5) & CSS(3)  
* JS(ES5、ES6、ES7、ES8、ES9、ES10、ES11、ES12等)  
* Vue  
* React   
* Webpack（因为太重要，所以单独说下）
* 后端(Node、Mysql、Redis等)&运维        
* 项目相关     
* 算法题&手写原理&做做题  

> 如果标题上加 ”，表示了解即可，不必强记

## HTTP(网络)   

### 简单说下网络模型“  

参考：[网络七层模型（四层模型）及其区别](https://juejin.cn/post/6844903939918266382)    



### 简单介绍下TCP连接 

TCP的三次握手和四次挥手，为什么一个要三次，一个要四次？  

因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。  

当关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。



参考：[TCP 三次握手 与 四次挥手](https://juejin.cn/post/6844903888529653767)  



### 说下TCP与UDP有什么区别？  

![MTCPAndUDP](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MTCPAndUDP.png)



### HTTP中的URI与URL有什么区别？  

**URI 是通用资源标识符，而 URL 是统一资源定位符。**

可以这样理解：

- URI可以表示一个域，也可以表示一个资源。
- URL只能表示一个资源。

因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 URN（Universal Resource Name），它命名资源但不指定如何定位资源（目前没有大规模运用）。



参考：[HTTP中 URI 与 URL 的区别](https://juejin.cn/post/6844903933631004680)



### 从输入一个网址到看到一张网页，经历了什么？  

1. DNS解析，找到IP地址
2. 根据IP地址，找到对应的服务器
3. 建立TCP连接(里面有个 三次握手)
4. 连接建立后，发出HTTP请求
5. 服务器根据请求作出HTTP响应
6. 浏览器得到响应内容，进行解析与渲染，并显示
7. 断开连接(四次挥手)

参考：[从输入一个网址到浏览器显示页面的全过程详细分析](https://juejin.cn/post/6844903888483516430)  



其中的某些过程说的越详细越好，比如拿到数据浏览器是如何渲染到页面上的(HTML树+CSS树=渲染树)  



### 简单说下HTTP协议  

HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。    



HTTP协议的特点：  

1.支持客户/服务器模式。支持基本认证和安全认证。

2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

4.HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。

5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 



HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”(具体内容请参考我的其他文章)。在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。  



HTTP的应用：  

1. 断点续传  
2. 多线程下载  
3. 代理  



参考：[HTTP协议简介](https://juejin.cn/post/6844903888563224583)  



### 了解HTTP中的代理吗？  

**代理服务器的工作流程：**

- 用户向代理发起TCP连接；
- 代理接收用户的连接，双方建立连接；
- 用户向代理发送HTTP请求，请求内容和没有HTTP代理的内容完全相同；
- 代理解析HTTP请求；
- 代理向服务器发起TCP连接；
- 服务器接收代理的连接；
- 代理向服务器发送HTTP请求（这个HTTP请求是基于用户的HTTP请求，可能会有修改）
- 服务器发送响应给代理；

如果不使用代理的话，HTTP的请求报文里会有一个
 `Connection: Keep-Alive`
 如果使用代理的话，HTTP的请求报文里`Connection`就变了
 `Proxy-Connection: Keep-Alive`

**HTTP 代理存在两种形式：普通模式、隧道代理**

- 普通模式

原理：HTTP 客户端向代理服务器发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection:keep-alive），同时向目标服务器发送请求，并将收到的响应转发给客户端。

- 隧道代理

原理：HTTP 客户端通过HTTP的CONNECT方法请求隧道代理，创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。  



### 正向代理与反向代理有什么区别？  

代理可以分为正向代理和反向代理两种。

正向代理需要客户端来配置，一般来说我们会通过浏览器或者操作系统提供的工具或者界面来配置。这个时候，代理对客户端不是透明的，客户端需要知道代理的地址并且手动配置。配置了代理，浏览器在发送请求的时候会对报文做特殊的修改。

反向代理对客户端是透明的，也就是说客户端一般不知道代理的存在，认为自己是直接和服务器通信。我们大部分访问的网站就是反向代理服务器，反向代理服务器会转发到真正的服务器，一般在反向代理这一层实现负载均衡和高可用的功能。而且这里也可以看到，客户端是不会知道真正服务器端的 ip 地址和端口的，这在一定程度上起到了安全保护的作用。



### HTTP状态响应码有哪些？  

罗列一些常见的状态码就行，没必要说那么详细  



参考：[HTTP状态码](https://juejin.cn/post/6844903888563224583#heading-6)   



### HTTP中的请求方法  

HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：

- OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
- HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。
- GET - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。
- POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
- PUT - 向指定资源位置上传其最新内容。
- DELETE - 请求服务器删除Request-URI所标识的资源。
- TRACE- 回显服务器收到的请求，主要用于测试或诊断。
- CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
- PATCH - 用来将局部修改应用于某一资源。



### GET与POST请求有什么区别？  

- 请求参数: GET把参数包含在URL中,用&连接起来; POST通过request body传递参数。
- 请求缓存: GET请求会被主动Cache,而POST请求不会，除非手动设置。
- 收藏为书签: GET请求支持收藏为书签, POST请求不支持。
- 安全性: POST比GET安全, GET请求在浏览器回退时是无害的,而POST会再次请求。
- 历史记录: GET请求参数会被完整保留在浏览历史记录里,而POST中的参数不会被保留。
- 编码方式: GET请求只能进行url编码,而POST支持多种编码方式。
- 参数数据类型: GET只接受ASCIl字符,而POST没有限制数据类型。
- 数据包: GET产生一个TCP数据包; POST可能产生两个TCP数据包。  



### HTTP优化策略(缓存)  

重点：缓存（强缓存与协商缓存，几乎必问）  

* 强制缓存如果生效，不需要再和服务器发生交互
* 而对比缓存不管是否生效，都需要与服务端发生交互。   

对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。

对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

**两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。**      

**浏览器缓存过程**  

1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；
2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存（也就是内存中）读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求
3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200
4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200



**产生的缓存一般放在内存中**  



参考：[HTTP前端性能优化(压缩与缓存)](https://juejin.cn/post/6844903940316725255)



### 说一下web缓存？  
1. web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本    
2. 缓存的好处   
   （1）减少不必要的请求  
   （2）降低服务器的压力，减少服务器的消耗  
   （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）  



### 你知道哪些HTTP的头？  

* 请求头：  
  * `accept-encoding` 告诉服务器，我接收的数据支持压缩格式  
  * `if-modified-since` 对比缓存  修改时间   
  *  `if-none-match` 摘要缓存  和`Etag`配对使用的  
  *  `user-agent` 不同设备自动带上这个头   判断什么样的设备，重定向到不同项目  
* 响应头：  
  * `Content-Type`  告诉浏览器  我给你的内容的类型  
  * `Content-Encoding`  告诉浏览器  我给你的内容的压缩格式   
  * `Cache-Control` 强制缓存  告诉浏览器，你多长时间之间，不要来访问我  
  * `Expires`  强缓   告诉浏览器，你多长时间之间，不要来访问我  
  * `Last-Modified` 对比缓存 和 `if-modified-since` 配对使用  
  * `Etag`   根据摘要做缓存   和 `if-none-match` 配对使用  
  *  `Lotaion`  重定向到 某个地方      



### HTTP和HTTPS有什么区别？  

- HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
- HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。   



HTTPS和HTTP的区别主要如下：
　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



**HTTPS的优点**

1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。  



**HTTPS的缺点（对比优点）**

1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近。

2、HTTPS连接缓存不如HTTP高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；

3、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

4、HTTPS协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。



### HTTP如何实现长连接？  

- 向的通道,它是可以保持一段时间不关闭的,因此TCP连接才有真正的长连接和短连接这一个说法。
- 长连接是指的是TCP连接,而不是HTTP连接。
- TCP长连接可以复用一个TCP连接来发起多次HTTP请求,这样可以减少资源消耗,比如一次请求HTML,短连接可能还需要请求后续的JS/CSS/图片等

要实现HTTP长连接,在响应头设置Connection为keep-alive, HTTP1.1默认是长连接,而HTTP 1.0协议也支持长连接，但是默认是关闭的。  



### HTTP1.X与HTTP2.X有什么区别？  

1.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
大家都知道HTTP1.X使用的是明文的文本传送，而HTTP2使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，通过流ID就牵扯出了第二个区别

2.HTTP2支持多路复用
因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求

3.HTTP2头部压缩
HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了

4.HTTP2支持服务器推送
HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容  



###  cookie, session，localStorage, sessionStorage有什么区别？  

* cookie 服务器种植的，每次请求都会带上cookie，不安全，解决无状态问题，最多4K，浪费流量  
* session 基于cookie  保存在服务器（内存，入库） 相对安全      
* localStorage 不能跨域存取   最大存5M   超过5M的数据就会丢失   在发送请求时，不会带上localStorage  
* sessionStorage 当浏览器关闭时，里面的数据就丢失  



前后端分离（前端调后端api接口）开发的：cookie，**主流：session 或 JWT**        



参考：[理解cookie、session、localStorage、sessionStorage的关系与区别](https://juejin.cn/post/6844903975800537096)    



### 说下JWT与Session有什么区别和优缺点？  



![MJWTAndSession](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MJWTAndSession.png)



### OAuth授权认证流程是什么？  

OAuth被广泛用于第三方登录，例如微信小程序等，主要用来获取用户的信息，流程：  



![MOAuth](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MOAuth.png)



### 什么是单点登录？怎么实现？  

单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一
SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统
SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作
当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证  

举例：    

淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录    



![Msingledian](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Msingledian.png)





### 说下进程与线程的区别？  

**进程(Process)与线程(Thread)的区别：**

- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
- 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。
- 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
- 对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
- 一个程序至少有一个进程,一个进程至少有一个线程.
- 线程的划分尺度小于进程，使得多线程程序的并发性高。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。



参考：[进程与线程、同步与异步、阻塞与非阻塞、并发与并行](https://juejin.cn/post/6844903848780234759)  



### 进程间的通信方式主要有哪些？    

- 匿名管道
- 命名管道
- 信号量
- 消息队列
- 信号
- 共享内存
- 套接字

从技术上划分又可以划分成以下四种：

1. 消息传递(管道，FIFO，消息队列)
2. 同步(互斥量，条件变量，读写锁等)
3. 共享内存(匿名的，命名的)
4. 远程过程调用



### 如何理解CDN？  

CDN (全称 Content Delivery Network)，即内容分发网络

构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。`CDN` 的关键技术主要有内容存储和分发技术

简单来讲，`CDN`就是根据用户位置分配最近的资源

于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**，其实就是缓存了源站内容的代理服务器。  



**实现CDN的关键点**  

* 负载均衡系统  
* 缓存代理    



**为什么使用CDN？**  

`CDN` 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度

`CDN` 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速

通过`CDN`的负载均衡系统，智能调度边缘节点提供服务，相当于`CDN`服务的大脑，而缓存系统相当于`CDN`的心脏，缓存命中直接返回给用户，否则回源  



### 说说你对WebSocket的理解？  

WebSocket，是一种网络传输协议，位于`OSI`模型的应用层。可在单个`TCP`连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅

客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输  



`websocket`服务器与客户端通过握手连接，连接成功后，**两者都能主动的向对方发送或接受数据**（服务端主要推动消息的关键点，现在的聊天功能的就是基于这个实现的）  



而在`websocket`出现之前，开发实时`web`应用的方式为轮询

不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果

轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 `CPU`资源  



**特点：**  

* 全双工通信  
* 二进制帧  
* 协议名(ws、wss)  
* 握手(一次)  



**优点：**  

- 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
- 更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
- 保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
- 更好的二进制支持：定义了二进制帧，更好处理二进制内容
- 支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
- 更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率  



**应用场景：**  

- 弹幕
- 媒体聊天
- 协同编辑
- 基于位置的应用
- 体育实况更新
- 股票基金报价实时更新



### 说下常见的前端漏洞及防护原理？  

* sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。  
* XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。  
* CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求    



**设置Cookie时如何防止XSS攻击？**  
在服务器端设置cookie的时候设置http-only,这样就可
以防止用户通过JS获取cookie。对cookie的读写或发送
一般有如下字段进行设置:  

 * http-only:只允许http或https请求读取cookie, JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.  
 * secure-only:只允许https请求读取,发送请求时自动发送cookie  
 * host-only:只允许主机域名与domain设置完成一致的网站才能访问该cookie。 



参考：[常见六大Web安全攻防解析](https://juejin.cn/post/6844903772930441230)



## HTML(5)&CSS(3)  



### 说下HTML5都新加了哪些特性？  

HTML5 是定义了 HTML 的标准的最新演进。 这个术语代表了两个不同的概念：

- 它是 HTML 语言的一个新的版本，具有新的元素，属性和行为，
- 以及可以使 Web 站点和应用更加多样化和功能更强大的更丰富的一套技术。 这套技术有时被称作 HTML5 & 它的朋友们 而且往往被缩减到仅是 HTML5。

从要对全部所有的 Web 开发人员有用这一点出发，这个参考页面链接了有关 HTML5 技术的大量资源，并且基于它们各自的功能，把它们归类成了若干组。

- **语义**：能够让你更恰当地描述你的内容是什么。
- **连通性**：能够让你和服务器之间通过创新的新技术方法进行通信。
- **离线 & 存储**：能够让网页在客户端本地存储数据以及更高效地离线运行。
- **多媒体**：使 video 和 audio 成为了在所有 Web 中的一等公民。
- **2D/3D 绘图 & 效果**：提供了一个更加分化范围的呈现选择。
- **性能 & 集成**：提供了非常显著的性能优化和更有效的计算机硬件使用。
- **设备访问 Device Access**：能够处理各种输入和输出设备。
- **样式设计**: 让作者们来创作更加复杂的主题吧。  



### 说下CSS3都新增了哪些特性  

大致说下就行，没必要说那么全。  

在不牺牲性能和语义结构的前提下，CSS3中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式(WOFF)也提供了更高的灵活性和控制性。



参考：[CSS3菜鸟教程](https://www.runoob.com/css3/css3-tutorial.html)  



### 说下Flex布局吧  

Flex（Flexible Box）布局 称为 "弹性布局"，可以为网页的布局提供最大的灵活性，取代了往常的 浮动（float） 布局，并且任何一个容器都可以设置 Flex 布局。    

> 注：设置 Flex 布局后，子元素的 Float 布局将失效     

参考： [Flex 布局教程](https://juejin.im/post/5cdfc6ade51d4510a9276955)  



### 说下盒模型

**标准盒子模型和IE盒子模型的区别**

- 在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸
- IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。


参考： [CSS 盒子模型](https://juejin.im/post/5d2dbecb6fb9a07eff00bbc3)    



### CSS中link和@import 的区别是什么？  

* link属于HTML标签，而@import是CSS提供的  
* 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载  
* import只在IE5以上才能识别，而link是HTML标签，无兼容问题  
* link方式的样式的权重 高于@import的权重.  



### 说下CSS的优先级  

不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性  

	1. 属性后面加!import 会覆盖页面内任何位置定义的元素样式
	2. 作为style属性写在元素内的样式
	3. id选择器
	4. 类选择器
	5. 标签选择器
	6. 通配符选择器（*）
	7. 浏览器自定义或继承  

**同一级别：后写的会覆盖先写的**



### 说下transition和animation的区别？  

Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，  

而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。



### 理解BFC吗？  

BFC 即 Block Formatting Contexts (块级格式化上下文)。    

具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。    

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 



参考：[理解CSS中的BFC](https://juejin.im/post/5da30040f265da5ba273c47d)    



### 使元素消失的方法有哪些?  

visibility:hidden、display:none、z-index=-1、opacity：0    

1. opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发    

2. visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件    

3. display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉  



### 为什么css放在顶部而js写在后面?  

1. 浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了    
2. 其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。      
3. js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验  



但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面    



### CSS会阻塞页面的加载和渲染吗？  

> 前置问题：js会阻塞DOM树的解析和渲染吗？  
>
> 答： 会  

那么CSS加载会阻塞DOM树的解析和渲染吗？  



首先了解一下浏览器渲染的流程：  

- HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree
- 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)
- 根据Render Tree渲染绘制，将像素渲染到屏幕上。  

从流程我们可以看出来  

* DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。

* 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。

* 由于js可能会操作之前的DOM节点和CSS，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。



**总结**  

由上所述，我们可以得出以下结论:

- css加载不会阻塞DOM树的解析
- css加载会阻塞DOM树的渲染
- css加载会阻塞后面js语句的执行

因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

- 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
- 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
- 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
- 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)



### 说下Less与Sass主要用来做什么？  

Less是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量、继承、运算、函数。

Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行。  



Sass是一种动态样式语言，Sass语法属于缩排语法，比CSS多出好多功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。

Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。

Less和Sass在语法上有些共性，比如下面这些：

1. 混入(Mixins)——class中的class；  
2. 参数混入——可以传递参数的class，就像函数一样；  
3. 嵌套规则——Class中嵌套class，从而减少重复的代码；  
4. 运算——CSS中用上数学；  
5. 颜色功能——可以编辑颜色；  
6. 名字空间(namespace)——分组样式，从而可以被调用；  
7. 作用域——局部修改样式；  
8. JavaScript 赋值——在CSS中使用JavaScript表达式赋值。

Less和Sass的主要不同就是他们的实现方式：  

* Less是基于JavaScript，是在客户端处理的。

* Sass是基于Ruby的，是在服务器端处理的。

关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。



### 说下回流(重排)和重绘吧

当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。

* 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少

* 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作  

触发回流的一些情况：

* 页面初次渲染  
* 浏览器窗口大小改变  
* 元素尺寸、位置、内容发生改变  
* 元素字体大小变化  
* 添加或者删除可见的 dom 元素  
* 激活 CSS 伪类（例如：:hover）  
* 查询某些属性或调用某些方法  

```javascript
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
getComputedStyle()
getBoundingClientRect()
scrollTo()
```



**回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。**  



**优化方案：**  

CSS：  

* 避免使用table布局  
* 将动画效果应用到position属性为absolute或fixed的元素上  

JS：  

* 避免频繁操作样式，可汇总后统一 一次修改  
* 尽量使用class进行样式修改  
* 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入  
* 极限优化时，修改样式可将其display: none后修改  
* 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用变量存住    



### 说下BOM与DOM的区别？  

`BOM（Browser Object Model）`是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。 使 `JavaScript` 有能力与浏览器"对话"。  


`DOM （Document Object Model）`是指文档对象模型，通过它，可以访问`HTML`文档的所有元素。 `DOM `是 `W3C`（万维网联盟）的标准。`DOM` 定义了访问 `HTML` 和` XML` 文档的标准： "W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。 `W3C DOM` 标准被分为 3 个不同的部分：

- 核心 `DOM` - 针对任何结构化文档的标准模型
- `XML DOM` - 针对 XML 文档的标准模型
- `HTML DOM` - 针对 HTML 文档的标准模型

什么是` XML DOM`？ `XML DOM` 定义了所有 XML 元素的对象和属性，以及访问它们的方法。 什么是 HTML DOM？ HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法



### href与src有什么区别？  

href是Hypertext Reference的简写，表示超文本**引用**，指向网络资源所在位置。  
常见场景:  

``` 
<a href="http://www.baidu.com"></a> 
<link type="text/css" rel="stylesheet" href="common.css">
```
src是source的简写，目的是要把文件**下载**到html页面中去。  

``` 
<img src="img/girl.jpg"> 
<iframe src="top.html"> 
<script src="show.js">
```
作用结果：  
* href 用于在当前文档和引用资源之间确立联系  
* src 用于替换当前内容    



### 使用REM时给body设置fontSize可以吗？  

> 说下px、em、rem有什么区别？  

这三个的区别是：

* px是固定的像素，一旦设置了就无法因为适应页面大小而改变。  
* em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素<HTML>。**  

但是如果元素自身设置了fontSize，那么em就根据自身进行计算，而不是父元素，如果自身没有设置fontSize，那么就会根据父元素进行设置  





### 实现0.5px的线  

个人感觉是最优解：  

```html
<style>
    .line {
        height: 1px;
        transform: scaleY(0.5);
        transform-origin: 50% 100%;
        background-color: black;
    }
</style>

<body>
    <p>1px + scaleY(0.5)</p>
    <div class='line'></div>
</body>
```



还有一种方法，使用boxshadow：    

这个方法在Chrome和Firefox都非常完美，但是Safari不支持小于1px的boxshadow，所以完全没显示出来。

```html
<style>
    .line {
        height: 1px;
        background: none;
        box-shadow: 0 0.5px 0 #000;
    }
</style>

<body>
    <p>box-shadow: 0 0.5px 0 #000</p>
    <div class='line'></div>
</body>
```



### 如何让一个DIV水平垂直居中？  

```html
<div class="parent">
  <div class="child"></div>
</div>
```

1.   ```css
     div.parent {
         display: flex;
         justify-content: center;
         align-items: center;
     }
     ```

   

2. ```css
   div.parent {
       position: relative; 
   }
   div.child {
       position: absolute; 
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);  
   }
   /* 或者 */
   div.child {
       width: 50px;
       height: 10px;
       position: absolute;
       top: 50%;
       left: 50%;
       margin-left: -25px;
       margin-top: -5px;
   }
   /* 或 */
   div.child {
       width: 50px;
       height: 10px;
       position: absolute;
       left: 0;
       top: 0;
       right: 0;
       bottom: 0;
       margin: auto;
   }
   ```

3. ```css
   div.parent {
       display: grid;
   }
   div.child {
       justify-self: center;
       align-self: center;
   }
   ```

4. ```css
   div.parent {
       font-size: 0;
       text-align: center;
       &::before {
           content: "";
           display: inline-block;
           width: 0;
           height: 100%;
           vertical-align: middle;
       }
   }
   div.child{
     display: inline-block;
     vertical-align: middle;
   }
   ```

5. ```css
   div.parent{
     display:flex;
   }
   div.child{
     margin:auto;
   }
   ```

6. ```css
   div.parent {
   	display: table;
   }
   div.child {
       display: table-cell
       vertical-align: middle;
       text-align: center;
   }
   ```



### 如何清除浮动？  

 通常在公共的css样式中定义一个清除浮动的类，哪里需要加哪里  

```css
.clearfix{
	clear:both;
	content:'.';
	display:block;
	width: 0;
	height: 0;
	visibility:hidden;
}
```



### 实现一个三栏布局  

三栏布局，顾名思义就是两边固定，中间自适应  



**流体布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    background-color: blue;
	    float: right;
	}
	.main {
	    margin-left: 120px;
	    margin-right: 220px;
	    height: 200px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```



**BFC**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    margin-right: 20px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    float: right;
	    margin-left: 20px;
	    background-color: blue;
	}	
	.main {
	    height: 200px;
	    overflow: hidden;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```



**圣杯布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    margin-left: 120px;
	    margin-right: 220px;
	}
	.main {
	    float: left;
	    width: 100%;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    float: left;
	    width: 100px;
	    height: 300px;
	    margin-left: -100%;
	    position: relative;
	    left: -120px;
	    background-color: blue;
	}
	.right {
	    float: left;
	    width: 200px;
	    height: 300px;
	    margin-left: -200px;
	    position: relative;
	    right: -220px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**Flex布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
            display: flex;
	}
	.main {
            flex-grow: 1;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    order: -1;
	    flex: 0 1 200px;
	    margin-right: 20px;
	    height: 300px;
	    background-color: blue;
	}
	.right {
	    flex: 0 1 100px;
            margin-left: 20px;
	    height: 300px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**Table布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .container {
	    display: table;
	    width: 100%;
        }
        .left, .main, .right {
	    display: table-cell;
        }
        .left {
	    width: 200px;
	    height: 300px;
	    background-color: red;
        }
        .main {
	    background-color: blue;
        }
        .right {
	    width: 100px;
	    height: 300px;
	    background-color: green;
        }
    </style>
</head>
<body>
    <div class="container">
	<div class="left"></div>
	<div class="main"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**定位布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    position: relative;
	}
	.main {
	    height: 400px;
	    margin: 0 120px;
	    background-color: green;
	}
	.left {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    left: 0;
	    top: 0;
	    background-color: red;
	}
	.right {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    background-color: blue;
            right: 0;
	    top: 0;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



### z-index有最大最小值吗？    

答：有，不同浏览器取值可能不同  

- 原理：

  当两个同父元素z-index相同时，后面的元素显示在上面。

  当z-index超过浏览器最大值时，浏览器会按最大值计算。  

* 汇总  

|        | ver.    | max        | min         | typeof(div.style.zIndex) |
| ------ | ------- | ---------- | ----------- | ------------------------ |
| IE     | 8.0     | 2147483647 | -2147483648 | number                   |
| Chrome | 3.0.195 | 2147483647 | -2147483648 | string                   |
| FF     | 3.5.7   | 2147483645 | -2147483647 | string                   |
| Opera  | 10.10   | 2147483584 | -2147483584 | string                   |

- 结论：

  当需要兼容以上所有浏览器时，z-index需使用 -2147483584 ~ 2147483584 范围内的数字



## JS  

前端面试的重中之重，面试的好不好就看你JS玩不6不6  



### JS中的数据类型有哪些？  

八种，分别是：string、number、boolean、undefined、null、symbol(ES6)、bigint(ES10)和object  



> 然后应该会问怎么判断这些数据类型？  

使用typeof、instanceof、原型  



typeof主要用来判断基本数据类型  

instanceof主要用来判断引用数据类型  



不过最好使用原型上的方法判断，是最准确的，写个方法：  

```javascript
function checkType(para) {
    return Object.prototype.toString.call(para).slice(8,-1)  
}
```



### 说下JS中你都用过哪些方法？  

点进去看看：[JS中常用方法总结](https://juejin.cn/post/6844903898189152263)

 

> 追问：说下forEach与Map的区别？  

forEach没有return  

Map可以return，从而组成一个新的数组



### NaN是什么类型的，在什么情况下会出现？  

NaN是属于JavaScript的数值类型Number类型。  
NaN意思是指数据not a number不是一个数字，但是NaN却属于数值类型。  

那么NaN在什么情况下会出现呢？  

```javascript
let a = 'abc'
let b = 5
let c = a * b
console.log(c)

console.log(NaN === NaN) // false
```



### JS中常用的位运算符有哪些？  

* 按位与(AND)`&` 

`&`以特定的方式组合操作二进制数中对应的位，如果对应的位都为1，那么结果就是1， 如果任意一个位是0 则结果就是0

```javascript
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 1的二进制表示为: 00000000 00000000 00000000 00000001
console.log(1 & 3)     // 1
```



* 按位或(OR)`|`  

`|` 运算符跟 `&` 的区别在于如果对应的位中任一个操作数为1 那么结果就是1。  

```javascript
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 3的二进制表示为: 00000000 00000000 00000000 00000011
console.log(1 | 3)     // 3
```



* 按位异或(XOR)`^`  

`^` 如果对应两个操作位有且仅有一个1时结果为1，其他都是0。  

```javascript
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 2的二进制表示为: 00000000 00000000 00000000 00000010
console.log(1 ^ 3)     // 2
```



* 按位非(NOT)`~`  

`~` 运算符是对位求反，1变0, 0变1，也就是求二进制的反码。  

```javascript
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 1反码二进制表示: 11111111 11111111 11111111 11111110
// 由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。
// -----------------------------
// 1的反码减1：     11111111 11111111 11111111 11111101
// 反码取反：       00000000 00000000 00000000 00000010
// 表示为10进制加负号：-2
console.log(~ 1)     // -2
```

> **简单记忆：一个数与自身的取反值相加等于-1**。  



* 左移(Left shift)`<<`  

`<<`运算符使指定值的二进制数所有位都左移指定次数，其移动规则：**丢弃高位，低位补0**即按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。  

```javascript
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// -----------------------------
// 2的二进制表示为: 00000000 00000000 00000000 00000010
console.log(1 << 1)     // 2
```



* 有符号右移`>>`  

`>>`该操作符会将指定操作数的二进制位向右移动指定的位数。**向右被移出的位被丢弃，拷贝最左侧的位以填充左侧**。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。  

```javascript
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// -----------------------------
// 0的二进制表示为: 00000000 00000000 00000000 00000000
console.log(1 >> 1)     // 0
```



* 无符号右移`>>>`  

`>>>`该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）

对于非负数，有符号右移和无符号右移总是返回相同的结果。例如， `9 >>> 2` 得到 `2 和 9 >> 2` 相同。



**妙用**  

1. 使用&运算符判断一个数的奇偶  

```javascript
// 偶数 & 1 = 0
// 奇数 & 1 = 1
console.log(2 & 1)    // 0
console.log(3 & 1)    // 1
```

2. 使用`~, >>, <<, >>>, |`来取整  

```javascript
console.log(~~ 6.83)    // 6
console.log(6.83 >> 0)  // 6
console.log(6.83 << 0)  // 6
console.log(6.83 | 0)   // 6
// >>>不可对负数取整
console.log(6.83 >>> 0)   // 6
```

3. 使用`^`来完成值交换  

```javascript
var a = 5
var b = 8
a ^= b
b ^= a
a ^= b
console.log(a)   // 8
console.log(b)   // 5
```

4. 使用`&, >>, |`来完成rgb值和16进制颜色值之间的转换  

```javascript
/**
 * 16进制颜色值转RGB
 * @param  {String} hex 16进制颜色字符串
 * @return {String}     RGB颜色字符串
 */
  function hexToRGB(hex) {
    var hexx = hex.replace('#', '0x')
    var r = hexx >> 16
    var g = hexx >> 8 & 0xff
    var b = hexx & 0xff
    return `rgb(${r}, ${g}, ${b})`
}

/**
 * RGB颜色转16进制颜色
 * @param  {String} rgb RGB进制颜色字符串
 * @return {String}     16进制颜色字符串
 */
function RGBToHex(rgb) {
    var rgbArr = rgb.split(/[^\d]+/)
    var color = rgbArr[1]<<16 | rgbArr[2]<<8 | rgbArr[3]
    return '#'+ color.toString(16)
}
// -------------------------------------------------
hexToRGB('#ffffff')               // 'rgb(255,255,255)'
RGBToHex('rgb(255,255,255)')      // '#ffffff'
```





### for...in...与for...of...有什么区别？  

for...in 循环只遍历可枚举属性（包括它的原型链上的可枚举属性）。像 Array和Object使用内置构造函数所创建的对象都会继承自Object.prototype和String.prototype的不可枚举属性，例如 String 的 indexOf()  方法或 Object的toString()方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。  

for...of语句在可迭代对象（包括Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句  

无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。
* for...in语句以任意顺序迭代对象的可枚举属性。  
* for...of 语句遍历可迭代对象定义要迭代的数据。    

总结：  
for in 一般用来遍历对象的key、for of 一般用来遍历数组的value  
for … in

* for … in 获取的是对象的键名;
* for … in会遍历对象的整个原型链,性能非常差不推荐使用;
* 对于数组的遍历,for … in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性);  


for … of
* for … of遍历获取的是对象的键值;
* for … of只遍历当前对象不会遍历原型链;
* 对于数组的遍历,for … of只返回数组的下标对应的属性值;



### 怎么结束for、forEach、Map循环？怎么跳出本轮循环、整个循环和嵌套循环？  

**return语句的作用**  

(1) return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行
(2) return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致，可以使用强制类型转换来是数据类型一致
(3) return 当方法说明中用void声明返回类型为空时，应使用这种格式，不返回任何值。  



**break语句的作用**  

(1) 只能在循环体内和switch语句体内使用break语句。
(2) 当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。
(3) 当break出现在循环体中，但并不在switch语句体内时，则在执行break后，跳出本层循环体。
(4) 在循环结构中，应用break语句使流程跳出本层循环体，从而提前结束本层循环  



**continue语句作用**  

(1) continue语句的一般形式为：continue;
(2) 其作用是结束本次循环，即跳过本次循环体中余下尚未执行的语句，接着再一次进行循环的条件判定。
(3) 注意：执行continue语句并没有使整个循环终止。在while和do-while循环中，continue语句使得流程直接跳到循环控制条件的测试部分 ，然后决定循环是否继续进行。
(4) 在for 循环中，遇到continue后，跳过循环体中余下的语句，而去对for语句中的“表达式3”求值，然后进行“表达式2”的条件测试，



### JS中实现页面跳转和刷新方法有哪些？  



参考：[JS中实现页面跳转和刷新方法总结](https://juejin.cn/post/6844903925741682696)    



### 说下JS中的事件模型和事件流    

**事件与事件流**  

`javascript`中的事件，可以理解就是在`HTML`文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等

由于`DOM`是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念

事件流都会经历三个阶段：

- 事件捕获阶段(capture phase)
- 处于目标阶段(target phase)
- 事件冒泡阶段(bubbling phase)  



![JSEvent](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/JSEvent.png)

**事件模型**  

事件模型可以分为三种：

- 原始事件模型（DOM0级）
- 标准事件模型（DOM2级）
- IE事件模型（基本不用）  



原始事件模型的特性：  

* 绑定速度快  
* 只支持冒泡，不支持捕获  
* 同一个类型的事件只能绑定一次



在标准事件模型中，一次事件共有三个过程:

- 事件捕获阶段：事件从`document`一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行
- 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数
- 事件冒泡阶段：事件从目标元素冒泡到`document`, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行



IE事件模型共有两个过程:

- 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。
- 事件冒泡阶段：事件从目标元素冒泡到`document`, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行



### JS会阻塞DOM的解析与渲染吗？  

> 是js的加载阻塞了页面的渲染还是js的执行阻塞了页面的渲染？  

答：js的加载会阻塞页面渲染，执行也会阻塞页面渲染。  



补充知识点：  

渲染线程从cpu或缓存中获取资源从上而下进行页面渲染，当遇到需要渲染外链文件时会先通知http线程去获取资源，成功后再渲染（只渲染不做是否符合规则的预判端也不做执行，因为这个是js线程负责的，与渲染线程无关），待js加载持行完成/或报错中断后（注：**渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行），再接着往下执行渲染。这开就是为什么js报错页面可以正常展示，js引入成功或失败前，该js往下的dom未渲染出来的原因。上述规则符合js，css等所有外链或内联资源放置html任何位置。

参考链接：[关于 JS 与 CSS 是否阻塞 DOM 的渲染和解析](https://juejin.cn/post/6973949865130885157)



> html与js是否是并行下载？  

答：html与js不是并行下载，因为输入url地址后，浏览器当前页的http线程获取当前html页面（注：只有视频，音频才有断点传输。所有http请求均为一段一段的数据传输，只有传输关闭或意外中断时才有返回码，html文件很小 所以视觉上有返回码时才开始页面渲染），并由渲染线程渲染html页面，渲染的过程中才有外链js的下载。  



> 是js的下载阻塞了页面的渲染还是js的执行阻塞了页面的渲染，还是两者都会阻塞页面？  

答：下载阻塞，执行时也阻塞，因为各线程各司其职的原因。另推测，下载时阻塞渲染也是浏览器开发者有意为之。举例说明：如果一个js依赖jQuery，那么jQuery应放在该js前面，如果下载时不阻塞渲染进程的话，则该js有可能比jq先渲染出来执行，则导致页面报错甚至功能失效。  



> css，图片以及一些其它的外部资源的下载是否与html，js的下载并行？  

答：图片与js，css可并行下载。js与css不能并行下载，js间不能并行下载，css间也不能并行下载，图片间为并行下载。（注：js不设为异步加载，图片加载比较特殊，http线程可同时发送多个请求，谁先返回返回码谁先加载，这就是为什么我们看到有些网页前面的图片没出来。  



http线程执行流程：  

1. 需要http请求时 先读取资源来源  
2. 挂载等待该资源返回（等待期间可以去干其它事）  
3. 获取请求返回的数据并给渲染线程渲染





**解决方法：**  

1. 推迟加载(延迟加载)  

如果页面初始的渲染并不依赖于js或者CSS可以用推迟加载，就是最后在加载js和css，把引用外部文件的代码写在最后。比如一些按钮的点击事件，比如轮播图动画的脚本也可以放在最后。  

2. defer延迟加载  

`<script src="" defer></script>`  

在文档解析完成开始执行，并且在DOMContentLoaded事件之前执行完成，会按照他们在文档出现的顺序去下载解析。效果和把script放在文档最后`</body>`之前是一样的。

注：defer最好用在引用外部文件中使用，用了defer不要使用document.write()方法;使用defer时最好不要请求样式信息，因为样式表可能尚未加载，浏览器会禁止该脚本等待样式表加载完成，相当于样式表阻塞脚本执行。

3. 异步加载  

* **async异步加载**：就是告诉浏览器不必等到加载完外部文件，可以边渲染边下载，什么时候下载完成什么时候执行。    

```javascript
<script type="text/javascript" src="" async></script>
```



注：用了async不要使用document.write()方法;使用async时最好不要请求样式信息，原因和defer一样。  

* **script dom element法**：这个方法是用js动态创建一个script元素添加在document中。  

```javascript
<script type="text/javascript">
    (function() {
     var s = document.createElement('script');
     s.type = 'text/javascript';
     s.async = true;                                        //这句可以删除，但是效果不变。
     s.src = 'js/a.js';
     var x = document.getElementsByTagName('script')[0];
     x.parentNode.insertBefore(s, x);
 })();
</script>
```

注意：这种方法会阻止onload事件



* **onload时异步加载**：这个和script dom element法差不多但是他不是同时执行js和html，他是等html的文件，图片之类的、页面所有的资源全部加载完成后再下载执行js，这样的方法可以避免阻塞onload事件的触发。   

```javascript
(function() {
      function async_load(){
          var s = document.createElement('script');
          s.type = 'text/javascript';
          s.async = true;
          s.src = 'js/yibujiaz.js';
          var x = document.getElementsByTagName('script')[0];
          x.parentNode.insertBefore(s, x);
      }
      if (window.attachEvent)
          window.attachEvent('onload', async_load);
      else
          window.addEventListener('load', async_load, false);
  })();
```

注：DOMContentLoaded与onload事件不同，DOMContentLoaded是页面解析完成，页面的dom元素可以使用，但是页面的图片、视频等资源可能还没加载完成。



### `==`与`===`的区别，是否`===`就完全靠谱？  

不一定靠谱，例如 `0 === -0`就为true，`NaN === NaN`为false，判断两个变量是否完全相等可以使用ES6新增的API，`Object.is(0, -0)`，就可以准确区分  



### JS的异步解决方案有哪些？  

* 回调函数（嵌套，回调地狱，不优雅）  
* Promise    
* Generator+co （co可以解决promise嵌套问题）  
* async+await：是Generator的语法糖    

**其实Generator和async+await本质上还是基于Promise实现的**  



参考：  

[JS中的异步解决方案](https://juejin.cn/post/6844903896486264845)  

[深入理解 promise、generator+co、async/await 用法](https://juejin.cn/post/6844903919554920461)    



### 说下Promise的实现原理  

手写Promise，后面《手写原理》会有，看后面  



### 关于Promise.then的链式调用问题  

> then可以链式调用，多个then时，如何走到下一个then的失败回调？  

答：  

1.返回一个失败的promise。  

2.抛出一个错误(throw new Error())    



> then可以链式调用，多个then时，如何终止下一个then的调用？  

答：  

返回一个处于pending(等待态)状态的promise



### 如何把一个伪数组转变为真实的数组？  

* 使用ES6中的展开运算符（ [...obj]，需要保证obj是可迭代的 ）  
* Array.from不需要保证obj是否迭代，内部会使它可迭代     
* 自定义一个genertor迭代器  



### 你都使用过ES6中的哪些语法？  

* let、const  
* 解构赋值  
* 展开运算符  
* 字符串、对象和数组中新加的方法(例：repeat、fill、flat)  
* Set和Map  
* Symbol  
* 箭头函数  
* Reflect和Proxy  
* Class  
* 模块化  
* Promise  

参考：[ES6 新增内容总结](https://juejin.cn/post/6844903902031118344)  



### var、let、const有什么区别？  



点击看下：[区别](https://juejin.cn/post/6844903902031118344#heading-0)  



> 做道题  

```javascript
for(var i=0; i<5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000)
}

// 输出结果是啥  
// 1S 后输出5个5
```

那么我怎么才能按顺序输出0，1，2，3，4呢？  



使用let关键字  

```javascript
for(let i=0; i<5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000)
}

// 输出结果：0,1,3,4,5
```

为什么使用let关键字可以？  

答：因为他会形成一个块级作用域  



如果不适用let关键字怎么解决呢？  

```javascript
for(var i=0; i<5; i++) {
    ((i) => {
        setTimeout(() => {
            console.log(i);
        }, 1000)
    })(i)
}

// 自己形成块级作用域即可
```



### 说下ES6中的模块化  



[点我](https://juejin.im/post/5d3eb1b6f265da03c23eacc2#heading-44)  


### ??和?.用过吗？  

  * Nullish coalescing Operator(空值处理)    

表达式在`??`的左侧 运算符求值为`undefined`或`null`，返回其右侧。  

```javascript  
let user = {
    u1: 0,
    u2: false,
    u3: null,
    u4: undefined
    u5: '',
}
let u2 = user.u2 ?? '用户2'  // false
let u3 = user.u3 ?? '用户3'  // 用户3
let u4 = user.u4 ?? '用户4'  // 用户4
let u5 = user.u5 ?? '用户5'  // ''
```

  * Optional chaining（可选链）    

`?.`用于检测不确定的中间节点  

```javascript  
let user = {}
let u1 = user.childer.name // TypeError: Cannot read property 'name' of undefined
let u1 = user.childer?.name // undefined
```



参考：[JS语法ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性](https://www.cnblogs.com/lhongsen/p/14846373.html)  




### 说下JS中的闭包以及应用场景  

什么是闭包？  

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

可以在内部函数访问到外部函数作用域。使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为null。  



1. 优点
* 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用  
* 避免变量污染全局    
* 把变量存到独立的作用域，作为私有成员存在
2. 缺点
* 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏  
* 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度  
* 可能获取到意外的值(captured value)  

应用场景：  

* 函数防抖节流  
* 函数柯里化  
* 使用闭包设计单例模式  
* 为多个组件设置独立属性  
* 设置私有变量  
* 拿到正确的值  



### 堆和栈有什么区别？  

堆中存的是引用数据类型，是动态分配的内存，大小不定也不会自动释放；  

栈中存的是基本数据类型，会自动分配内存空间，自动释放；



- 堆(heap):也可以叫堆内存；是一种队列优先，先进先出的数据结构；
- 栈(stack):又名'堆栈',也是一种数据结构，不过它是按照先进后出原则存储数据的。  




使用JS代码实现队列和栈的功能（就是用数组的增删方法）：  

- 实现队列的方法（先进先出）

```
let arr = new Array();
arr.push(1);
arr.push(2);
arr.shift();
复制代码
```

- 实现栈的方法（先进后出）

```
let arr = new Array();
arr.push(1);
arr.push(2);
arr.pop();
```



### JS深拷贝与浅拷贝的区别？  

**浅拷贝**  

只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存；

简单的说，浅拷贝就是将一个对象的内存地址的“”编号“”复制给另一个对象。即在真正访问的时候还是会访问到被复制对象。 或者只是深拷贝了第一层的引用类型，而没有拷贝更深层次的应用类型，而是利用复制地址的方式，这也是浅拷贝。

**深拷贝**  

复制并创建一个一模一样的对象，不共享内存，修改新对象，旧对象保持不变。

简单的说，深拷贝就是先新建一个空对象，内存中新开辟一块地址，把被复制对象的所有可枚举的(注意可枚举的对象)属性方法一一复制过来，注意要用递归来复制子对象里面的所有属性和方法，直到子子.....属性为基本数据类型。
 **关键点：开辟新内存、递归复制。**



> 实现一个深拷贝  

```javascript
// 深拷贝
function deepClone(source) {
    // 判断复制的目标是数组还是对象
    const target = source.constructor === Array ? [] : {}
    // 遍历目标
    for (const key in source) {
        if (source[key] && typeof source[key] === 'object') {
            // 对象 || 数组
            target[key] = source[key].constructor === Array ? [] : {}
            target[key] = deepClone(source[key])
        } else {
            // 不是对象或者数组，直接赋值
            target[key] = source[key]
        }
    }
    return target
}
```



参考：[理解JS中的浅拷贝与深拷贝](https://juejin.cn/post/6844903962424934407)





### 说下EventLoop(事件环)  



[JS(浏览器)事件环 (宏、微任务)](https://juejin.cn/post/6844903914085564423)  



### 说下JS中的原型和原型链  

参考：[JavaScript 原型 与 原型链](https://juejin.cn/post/6844903914085564423)  



```javascript
function A() {}
let a = new A()

// console.log(a.__proto__ == A.prototype) // true

// console.log(A.prototype.__proto__ == Object.prototype)  // true

// console.log(Object.prototype.__proto__ == null)  // true

// console.log(A.prototype.constructor == A)   // true
```



### 说下JS中的作用域和作用域链  



参考：[JavaScript 作用域 与 作用域链](https://juejin.cn/post/6844903901074980871)  



### JS中new做了什么？  

- 创建了一个空对象
- 绑定this值
- 链接到原型
- 返回新对象  



参考：[JS中 new究竟做了什么？](https://juejin.cn/post/6844903896326864910)  



### 说下箭头函数和普通函数有什么区别？  

主要区别就是this关键字的问题  

箭头函数中没有this  

**箭头函数中谁调用了包含this的方法，那么this就指向谁**      



> 这时候十有八九会让你做道题，后面做题环节再试下  



### 怎么改变this的指向？  



参考：[JS中改变this的指向 call、apply 和 bind 的区别](https://juejin.cn/post/6844903895743856654)  



### JS常见的设计模式"  

* 构造函数设计模式  
* 原型模式  
* 模块设计模式  
* 单例模式  
* 工厂模式  
* 观察者模式  
* 命令模式  
* 装饰模式  
* MVC模式  
* MVVM模式    



### 观察者模式和发布订阅模式有什么区别？  



观察者模式中： 
* 状态发布者维护了一个观察者的列表，明确的知道有哪些观察者存在，将状态变化直接通知给观察者
* 状态的观察者也明确的知道自己观察的状态是描述的哪一个对象
* 甚至需要这种相互知道的关系来处理逻辑（比如需要明确知道哪一个按钮被点击，处理对应的逻辑）

发布订阅模式：  
* 事件的发布者只发布事件，不关心这个事件被谁获取了，通常将事件发给一个中间件，由中间件再去分发事件
* 事件的订阅者只关心事件本身，不关心这个事件是谁发布的，通常在中间件中去注册观察某个事件
* 中间件中去维护事件类别对应的订阅者列表，当收到事件后，去对应列表中通知订阅者们  

参考：[两种模式讲解](https://juejin.cn/post/6844903921211670536)    



> 追问：能给我简单实现这两种模式吗？  

**观察者模式简单实现**

```javascript
//被观察者
class Subject{
    constructor(){
        this.arr = []   //存储观察者
        this.state = "开心..."  //存储被观察者状态
    }
    attach(unit){
        this.arr.push(unit)
    }
    //改变状态
    setState(newState){
        this.state = newState
        this.arr.forEach(unit=>unit.update(newState))
    }
}
//观察者
class Observer{
    constructor(name){
        this.name = name
    }
    update(newState){
        console.log(this.name,"状态：",newState);
    }
}
let s = new Subject("宝宝")
let o1 = new Observer("我")
let o2 = new Observer("你")

s.attach(o1)
s.attach(o2)
console.log(s.state);   //开心...
s.setState("不开心...");    //我 状态： 不开心...   你 状态： 不开心...
console.log(s.state);   //不开心...
```



**发布订阅简单实现**  

```javascript
let e = {
    arr:[],
    on(fn){
        this.arr.push(fn)
    },
    emit(){
        this.arr.forEach(fn=>fn())
    }
}
e.on(()=>{
    console.log("哈哈 1");
})
e.on(()=>{
    console.log("哈哈 2");
})

//调一次打印一次
e.emit()    //哈哈 1  哈哈 2  
e.emit()    //哈哈 1  哈哈 2 
```







### JS阻止冒泡和取消默认事件  

防止冒泡和捕获：    

w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true  

stopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。    



取消默认事件：   

w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;    



总结使用方法：
当需要停止冒泡行为时，可以使用  

```javascript
function stopBubble(e) { 
//如果提供了事件对象，则这是一个非IE浏览器 
if ( e && e.stopPropagation ) 
    //因此它支持W3C的stopPropagation()方法 
    e.stopPropagation(); 
else 
    //否则，我们需要使用IE的方式来取消事件冒泡 
    window.event.cancelBubble = true; 
}
```



当需要阻止默认行为时，可以使用    

```javascript
//阻止浏览器的默认行为 
function stopDefault( e ) { 
    //阻止默认浏览器动作(W3C) 
    if ( e && e.preventDefault ) 
        e.preventDefault(); 
    //IE中阻止函数器默认动作的方式 
    else 
        window.event.returnValue = false; 
    return false; 
}
```



### JS是如何运行的？”  

JS代码 ——>解析成AST (期间伴随词法分析、语法分析)——>生成字节码(V8)——>生成机器码(编译器)



### Jquery的优点？  

1.轻量
2.丰富的DOM选择器
3.链式表达式
4.事件、样式、动画支持
5.跨浏览器兼容
6.可扩展性  



### 怎么判断DOM加载完成？  

判断所有DOM加载完成使用onload  

``` javascript
window.onload = function(){
    
}
```
判断某个DOM节点是否加载完毕  

**readyState**  

document.readyState 返回当前文档的状态，属性如下： 
* uninitialized 还未开始加载
* loading 加载中
* interactive 已加载，文档与用户可以开始交互
* complete 加载完成

**DOMContentLoaded**    

当 DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash  



### Jquery(callback)这个callback有什么用？  

当传进去的参数是函数的时候，则在document对象上绑定一个ready事件监听函数，当DOM结构加载完成的时候执行    



```javascript
$(function(){

})
//以上代码和下面的效果是一样的
$(document).ready(function(){
    ...//代码
})
```



### Jquery与Zepto有什么区别？  

Zepto专用于手机端    

jQuery专用于pc端 （但jq又开发出了jquery-mobile,专门用于手机）    

* Zepto特点：Zepto是为现代智能手机浏览器推出的Javascript 框架, 有着和jQuery相似的语法, 但是和jQuery相比下来, 他有很多的优点, 在大小方面 , 压缩后的 zepto.min.js 大小只有21K, 使用服务器端 gzip 压缩后大小只有5~10K, 可以说非常的小, 功能很齐全, 并且多出来了一些触摸屏的事件,它对PC的浏览器就不是那么理想,尤其是在IE上直接过滤不兼容, 所以这个轻量级的js用它来开发手机端和iOS，Android网页都是是不错的选择，极大的减轻了整个app的负载量。  

* jquery特点：jquery主要是用于PC端的页面开发中，jquery是目前最流行的javascript框架，以其兼容全部主流浏览器，插件丰富，代码简洁，最关键的是更新快，其中最好的dom选择器被广泛的使用。而手机wap方面的话，jquery也推出jquery-mobile，也很好用。  

* 相同点：Zepto最初是为移动端开发的库，是jQuery的轻量级替代品，因为它的API和jQuery相似，而文件更小。Zepto最大的优势是它的文件大小，只有8k多，是目前功能完备的库中最小的一个，尽管不大，Zepto所提供的工具足以满足开发程序的需要。大多数在jQuery中·常用的API和方法Zepto都有，Zepto中还有一些jQuery中没有的。另外，因为Zepto的API大部分都能和jQuery兼容，所以用起来极其容易，如果熟悉jQuery，就能很容易掌握Zepto。你可用同样的方式重用jQuery中的很多方法，也可以方面地把方法串在一起得到更简洁的代码，甚至不用看它的文档。  

* 不同点：  
  * 针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。  
  * Dom操作的区别  
  * 事件触发的区别  
  * 事件委托的区别  
  * width()和height()的区别：Zepto由盒模型(box-sizing)决定，jQuery会忽略盒模型  
  * 等等。。。  



### JS隐式类型转换了解过吗？  

先说出下面代码执行结果(当时面试的时候做错了)

```javascript
if([] == false) {
  console.log(1)
}

if({} == false) {
  console.log(2)
}

if([]) {
  console.log(3)
}

if([1] == [1]) {
  console.log(4)
}
```



**使用==比较中的5条规则**  

* 规则 1：`NaN`和其他任何类型比较永远返回`false`（包括和他自己）  
* 规则 2：`Boolean `和其他任何类型比较，`Boolean `首先被转换为 `Number `类型    
* 规则 3：`String`和`Number`比较，先将`String`转换为`Number`类型。  
* 规则 4：`null == undefined`比较结果是`true`，除此之外，`null`、`undefined`和其他任何结果的比较值都为`false`。  
* 规则 5：`原始类型`和`引用类型`做比较时，引用类型会依照`ToPrimitive`规则转换为原始类型。



**类型转换表**  



![convert-table](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/convert-table.png)



参考：[JavaScript 隐式类型转换](https://chinese.freecodecamp.org/news/javascript-implicit-type-conversion/)    



### 说下什么是内存泄漏？  

内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存

并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费

程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存

对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃  



**垃圾回收机制**  

Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存

原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存

通常情况下有两种实现方式：

- 标记清除
- 引用计数



>  标记清除

`JavaScript`最常用的垃圾收回机制

当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“

垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉

在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了

随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存

举个例子：

```javascript
var m = 0,n = 19 // 把 m,n,add() 标记为进入环境。
add(m, n) // 把 a, b, c标记为进入环境。
console.log(n) // a,b,c标记为离开环境，等待垃圾回收。
function add(a, b) {
  a++
  var c = a + b
  return c
}
```

> 引用计数

语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放

如果一个值不再需要了，引用数却不为`0`，垃圾回收机制无法释放这块内存，从而导致内存泄漏

```javascript
const arr = [1, 2, 3, 4];
console.log('hello world');
```

面代码中，数组`[1, 2, 3, 4]`是一个值，会占用内存。变量`arr`是仅有的对这个值的引用，因此引用次数为`1`。尽管后面的代码没有用到`arr`，它还是会持续占用内存

如果需要这块内存被垃圾回收机制释放，只需要设置如下：

```javascript
arr = null
```

通过设置`arr`为`null`，就解除了对数组`[1,2,3,4]`的引用，引用次数变为 0，就被垃圾回收了



### 说下函数的防抖和节流以及实现  

**防抖(debounce)：**

在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

> 典型的案例就是输入框搜索：输入结束后n秒才进行搜索请求，n秒内又输入的内容，则重新计时。  



**节流(throttle)：**

规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。

> 典型的案例就是鼠标不断点击触发，规定在n秒内多次点击只生效一次。



简单封装：  

```javascript
// 防抖(在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时)
function debounce(fn, delay) {
    let t = delay || 500
    let timer
    return function() {
        clearTimeout(timer)
        timer = setTimeout(() => {
            // 改变this指向并传递参数
            fn.apply(this, arguments)
        }, t)
    }
}

/**

HTML代码示例

<body>
    <div id="container"></div>
</body>
<script>
    let count = 1
    let container = document.getElementById('container')
    function test(e) {
        // 如果debounce不加参数arguments，这里会打印undefined
        console.log(e)
        // 如果debounce不改变this指向，这里会打印window,而不是DOM节点
        console.log(this)
        container.innerHTML = count++;
    }
    function debounce(fn, delay) {
        let t = delay || 500
        let timer
        return function() {
            clearTimeout(timer)
            timer = setTimeout(() => {
                fn.apply(this, arguments)
            }, t)
        }
    }
    container.onmousemove = debounce(test, 1000)
</script>

 */
```



```javascript
// 节流(规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效)
function throttle(fn, delay) {
    let t = delay || 500
    let timer
    return function() {
        if (!timer) {
            timer = setTimeout(() => {
                // 为了方便下次执行定时器
                timer = null
                fn.apply(this, arguments)
            }, t)
        }
    }
}

/**

HTML代码示例

<body>
    <div id="container"></div>
</body>
<script>
    let count = 1
    let container = document.getElementById('container')
    function test() {
        container.innerHTML = count++;
    }
    function throttle(fn, delay) {
        let t = delay || 500
        let timer
        return function() {
            if (!timer) {
                timer = setTimeout(() => {
                    // 为了方便下次执行定时器
                    timer = null
                    fn.apply(this, arguments)
                }, t)
            }
        }
    }
    container.onmousemove = throttle(test, 2000)
</script>

 */
```



参考：[Vue 防抖与节流の使用](https://juejin.cn/post/6844903994121256973)



### 为什么0.1+0.2!==0.3?  

**因为计算机使用的是二进制**  



参考：[详情参考](https://juejin.cn/post/6844903680362151950)



### 说下TS主要是干什么的？  

简而言之，TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。从技术上讲TypeScript就是具有静态类型的 JavaScript 。  



什么是 TypeScript？

- TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。
- TypeScript 是一门静态类型、弱类型的语言。
- TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。
- TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。
- TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。
- TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。
- TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。
- TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。
- TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3）。  



> TS的类型主要有哪些？   

* String  

* Boolean  

* Number   

* Null  

* Undefined  

* Array  

* Tuple(元组)  

* Enum(枚举)  

* Any(任意类型)  

* Void(没有任何类型)    

* Never(不存在的值的类型)  

* 断言  

* ..............

  

### 使用JS实现一个链表  



参考：[用 JavaScript 实现一个链表](https://chinese.freecodecamp.org/news/implementing-a-linked-list-in-javascript/)  



### 怎么遍历一个链表？  



参考：[JS中的链表操作](https://www.cnblogs.com/WindrunnerMax/p/12881550.html)  





## Vue  



### 说下MVC、MVP、MVVM有什么区别？  

**MVC**  

实线表示调用，虚线表示通知   

![MMVC1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MMVC1.png)

Controller 是 MVC 中的 C，指控制层，在 Controller 层会接收用户所有的操作，并根据写好的代码进行相应的操作——触发 Model 层，或者触发 View 层，抑或是两者都触发。  
需要注意：Controller 层触发 View 层时，并不会更新 View 层中的数据，View 层中的数据是通过监听 Model 层数据变化而自动更新的，与 Controller 层无关。    

![MMVC2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MMVC2.png)



**MVP**  

![MMVP1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MMVP1.png)

在 MVC 框架中，View 层可以通过访问 Model 层来更新，但在 MVP 框架中，View 层不能再直接访问 Model 层，必须通过 Presenter 层提供的接口，然后 Presenter 层再去访问 Model 层。

这看起来有点多此一举，但用处着实不小，主要有两点：  
* 首先是因为 Model 层和 View 层都必须通过 Presenter 层来传递信息，所以完全分离了 View 层和 Model 层，也就是说，View 层与 Model 层一点关系也没有，双方是不知道彼此存在的，在它们眼里，只有 Presenter 层。  
* 其次，因为 View 层与 Model 层没有关系，所以 View 层可以抽离出来做成组件，在复用性上比 MVC 模型好很多。    

![MMVP2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MMVP2.png)

View 层与 Model 层确实互不干涉，View 层也自由了很多。但还是有问题，因为 View 层和 Model 层都需经过 Presenter 层，致使 Presenter 层比较复杂，维护起来会有一定的问题。  
而且因为没有绑定数据，所有数据都需要 Presenter 层进行“手动同步”，代码量比较大，虽然比 MVC 模型好很多，但也是有比较多的冗余部分。    



**MVVM**  

![MMVVM1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MMVVM1.png)

可能感觉 MVVM 的框架图与 MVP 的框架图相似，确实如此，两者都是从 View 层开始触发用户的操作，之后经过第三层，最后到达 Model 层。但是关键问题是这第三层的内容， ViewModel 层双向绑定了 View 层和 Model 层，因此，随着 View 层的数据变化，系统会自动修改 Model 层的数据，反之同理。而 Presenter 层是采用手动写方法来调用或者修改 View 层和 Model 层，两者孰优孰劣不言而喻。    

![MMVVM2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MMVVM2.png)





### Vue是什么？  

Vue.js（是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。    

Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。    

另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。    

Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。   



### 说下MVVM模式的实现原理  

即Model-View-ViewModel。  

Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化  

ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。    

DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。      



参考：[Vue MVVM理解及原理实现](https://juejin.cn/post/6844903929298288647)



### 说下Vue的双向绑定数据的原理  

Vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。  



### 简要说明Vue 2.x的全链路运作机制？  

 

1. 初始化以及挂载init, mount    
2. 再进行模板编译compile,将template编译为渲染函数render function    
3. 执行render function生成Virtual DOM, render function => VNode tree     
4. 再进行响应式依赖收集, render function=> getter,setter => Watcher.update => patch。以及使用队列进行异步更新的策略。    
5. 最后通过diff算法后进行patch更新视图



### 说下Vue的优缺点？  

- 优点

  - 易用

  ```
  已经会了 HTML、CSS、JavaScript？
  ```

  - 灵活

  ```
  1.拥有不断繁荣的生态系统(vue route, vuex,vue服务端渲染)
  2.可以使用一个库或者一个框架进行开发
  ```

  - 高效

  ```
  运行大小20kB,
  ```

  ```
  超快虚拟 DOM
  浏览器解析页面步骤                         :  
  	1.解析HTML,生成HTML树,
  	2.解析css,生成样式树,
  	3.HTML和css结合,
  	4.生成坐标点
  	5.开始渲染页面
  	
  举个栗子:
  	如果有一个元素需要修改,浏览器执行一次以上5个步骤,如果有10个元素需要修改,此时浏览器需要执行以上10次5个步骤.
  	
  虚拟dom(virtual dom)
  虚拟dom存在于内存当中,可以把它理解为一个Object(对象)
  如果有需要修改的元素,把它放在虚拟DOM中进行修改,修改完成之后,虚拟DOM会自动的跟真实的DOM进行对比,将产生差异的部分,进行页面的渲染.
  
  
  如果渲染页面时,采用了vue,
  如果需要修改10个元素,统一放在虚拟DOM中进行执行修改,修改完成之后,将虚拟DOM和真实DOM进行对比,产生差异的部分,统一再次进行页面的渲染.这样的执行只需执行以上1次五个步骤.
  
  优势:
  	1.高效.
  	2.浏览器只需执行一次修改.
  	3.js解析js比浏览器解析js快的多.
  ```

  ```
  最省心的优化
  1.transform:对元素进行2D或者3D转换,在写样式时,需要在前边增加各种前缀:-webkit -moz -o -ms,如果使用了vue,既不需要在前边那些前缀了/.vue中做了集成的优化.
  2.之前在js中操作元素:  先获取 加事件 在操作
   如果你是用vue,直接操作数据即可.
  ```

  - 渐进式javascript框架  
  - SPA(single page application)单页面应用

  ```
  普通页面之间跳转: 就是真实的页面之间进行跳转(N.html)
  单页面之间跳转:  始终只有一个页面(index.html)
  
  优点:
  	1.用户体验好.
  	2.适合前后端分离
  缺点:
  	1.不利于SEO优化.
  	2.首屏加载速度慢.加载时,将所有的css,js文件进行加载.
  ```

- 缺点

```
1.不利于SEO优化.
2.首屏加载速度慢.加载时,将所有的css,js文件进行加载.
3.不支持IE8以下
```



### 单页面应用和多页面应用区别及优缺点  

* 单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源，多应用于pc端。  

* 多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新。  

单页面的优点：   

* 用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小    
* 前后端分离    
* 页面效果会比较炫酷（比如切换页面内容时的专场动画）   

单页面缺点：    

* 初次加载时耗时多    
* 页面复杂度提高很多    
* 导航不可用，如果一定要导航需要自行实现前进、后退。



### Vue的两个核心是什么？  

* 数据驱动  
* 组件系统  



### 能说下Vue的响应式系统吗？  

* 任何一个 Vue Component 都有一个与之对应的 Watcher 实例  
* Vue 的 data 上的属性会被添加 getter 和 setter 属性  
* 当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)  
* data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新    



### 说下v-show与v-if的区别？  

都是条件渲染指令  

与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中，v-show指令只是设置了元素CSS的style值  ；  

而只有当v-if的值为true，元素才会存在于HTML代码中。



### 为什么避免 v-if 和 v-for 用在一起？   

当Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着v-if将分别重复运行于每个v-for循环中。  

通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。  



> Vue3.x中调整了这两个指令的优先级，不会出现这样的问题



### 说下Vue的生命周期以及应用？  

Vue的生命周期主要分为beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed   



**简单应用：**

**beforeCreate** : 可以在这加个loading事件，在加载实例时触发

**created** : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用

**mounted** : 挂载元素，获取到DOM节点

**updated** : 如果对数据统一处理，在这里写上相应函数

**beforeDestroy** : 可以做一个确认停止事件的确认框



**注：mounted中调用方法改变data数据可能引起二次渲染**



参考：[Vue 生命周期与钩子函数](https://juejin.im/post/5d4591315188257b6546f04e)  



### 你通常在哪个生命周期内调用异步请求？  

可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。  

但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

* 能更快获取到服务端数据，减少页面 loading 时间；  
* ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；  



### 说下keep-alive指令  

`keep-alive`是`vue`中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染`DOM`

`keep-alive` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们

`keep-alive`可以设置以下`props`属性：

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存
- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存
- `max` - 数字。最多可以缓存多少组件实例



关于`keep-alive`的基本用法：  

```vue
<keep-alive>
  <component :is="view"></component>
</keep-alive>
```

使用`includes`和`exclude`：  

```vue
<keep-alive include="a,b">
  <component :is="view"></component>
</keep-alive>

<!-- 正则表达式 (使用 `v-bind`) -->
<keep-alive :include="/a|b/">
  <component :is="view"></component>
</keep-alive>

<!-- 数组 (使用 `v-bind`) -->
<keep-alive :include="['a', 'b']">
  <component :is="view"></component>
</keep-alive>
```

匹配首先检查组件自身的 `name` 选项，如果 `name` 选项不可用，则匹配它的局部注册名称 (父组件 `components` 选项的键值)，匿名组件不能被匹配

设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（`activated`与`deactivated`）：

- 首次进入组件时：`beforeRouteEnter` > `beforeCreate` > `created`> `mounted` > `activated` > ... ... > `beforeRouteLeave` > `deactivated`
- 再次进入组件时：`beforeRouteEnter` >`activated` > ... ... > `beforeRouteLeave` > `deactivated`


参考：[Vue中keep-alive的深入理解和使用](https://juejin.cn/post/6844903918313406472)


### 说下Vue的导航守卫  

全局的  
* router.beforeEach  
* router.beforeResolve  
* router.afterEach  

单个路由独享的  
* beforeEnter  

组件级的  
* beforeRouteEnter  
* beforeRouteUpdate  
* beforeRouteLeave    

参考：[Vue 导航守卫(路由的生命周期)](https://juejin.im/post/5d529884f265da03a1484e56)    



### 说下route和router的区别是什么？



route是“路由信息对象”，包括path,params,hash,query,fullPath,matched,name等路由信息参数。  

router是“路由实例对象”，包括了路由的跳转方法(push、replace)，钩子函数等。  



### 说下Vue中的路由嵌套

路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转。    

router-view本身就是将组件渲染到该位置。



### 如何让CSS只在当前组件中起作用？  

在当前组件的`<style>`标签中添加`scoped`属性  



之后在项目编译后每个组件会生成独有的hash值用来区分。(通常在vue项目编译后审查的时候你都会看到例如`data-hdsiuhbjc`的东西，就是通过这个来区分的)  



### Vue中怎么重置data？  

Vue实例中的`$options`保留了初始化组件中的所有状态 。  



### 说下Vue中常用的指令以及修饰符  

**常用的指令：**  

* v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。

* v-show：根据表达式之真假值，切换元素的 display CSS 属性。

* v-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0以上必须需配合 key值 使用。

* v-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。

* v-on：用于监听指定元素的DOM事件，比如点击事件。绑定事件监听器。

* v-model：实现表单输入和应用状态之间的双向绑定

* v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。

* v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。





**v-model指令常用修饰符：**

* .lazy - 取代 input 监听 change 事件

* .number - 输入字符串转为数字

* .trim - 输入首尾空格过滤



**v-on指令常用修饰符：**  

* .stop - 调用 event.stopPropagation()，禁止事件冒泡。

* .prevent - 调用 event.preventDefault()，阻止事件默认行为。

* .capture - 添加事件侦听器时使用 capture 模式。

* .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。

* .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。

* .native - 监听组件根元素的原生事件。

* .once - 只触发一次回调。

* .left - (2.2.0) 只当点击鼠标左键时触发。

* .right - (2.2.0) 只当点击鼠标右键时触发。

* .middle - (2.2.0) 只当点击鼠标中键时触发。

* .passive - (2.3.0) 以 { passive: true } 模式添加侦听器。



**v-bind指令常用修饰符：**

* .prop - 被用于绑定 DOM 属性 (property)

* .camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)

* .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器



### 你自定义过指令吗？  

先了解下Vue.use做了哪些事？  

* 检查插件是否安装，如果安装了就不再安装  
* 如果没有安装，那么调用插件的install方法，并传入Vue实例      



Vue 自定义指令有全局注册和局部注册两种方式。    

注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。   

指令定义函数提供了几个钩子函数（可选）：
* bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。
* inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。
* update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。
* componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。
* unbind: 只调用一次， 指令与元素解绑时调用。  



![VueDefinition](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/VueDefinition.png)





### Vue中key值的作用   

当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。  

**key 的作用主要是为了高效的更新虚拟DOM**  



> 追问：为什么key必须要唯一，且不要用index作为key？  

key为什么要唯一？  

答：key的作用主要是为了高效的更新虚拟dom，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少dom操作量，提高性能。



为什么不要用index作为key？  

* 如果用index作为key，那么key设置的就没什么意义，并不会使patch过程变得高效  
* 会出现意想不到的bug  
* 列表的顺序难以保证  



给个例子：  

```vue
<template>
    <div id="app">
        使用唯一标识id作为key值
        <div v-for="item in list" :key="item.id">
            {{item.name}}
            <input type="text">
        </div>
        <hr>
        使用index作为key值
        <div v-for="(item, index) in list" :key="index">
            {{item.name}}
            <input type="text">
        </div>
        <hr>
        <button @click="add">往列表头部添加一条数据</button>
    </div>
</template>

<script>
export default {
    name: 'App',
    data() {
        return {
            list: [
                {
                    id: 1,
                    name: 'fan',
                },
                {
                    id: 2,
                    name: 'jun',
                },
                {
                    id: 3,
                    name: 'yang',
                },
            ]
        }
    },
    methods: {
        add() {
            this.list = [{id: 4, name: 'hello'}, ...this.list]
        }
    },
}
</script>
```

在输入框里输入值，然后往列表头部添加数据的时候（触发add方法），会发生意想不到的bug，看到没，如果用index作为key，输入框里的数据错乱了  

![key](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/key.gif)

### 谈谈你对虚拟DOM的理解？   

首先,我们都知道在前端性能优化的一个秘诀就是尽可能少地操作DOM,不仅仅是DOM相对较慢,更因为频繁变动DOM会造成浏览器的回流或者重绘,这些都是性能的杀手,因此我们需要这一层抽象,在patch过程中尽可能地一次性将差异更新到DOM中,这样保证了DOM不会出现性能很差的情况.  

其次,现代前端框架的一个基本要求就是无须手动操作DOM,一方面是因为手动操作DOM无法保证程序性能,多人协作的项目中如果review不严格,可能会有开发者写出性能较低的代码,另一方面更重要的是省略手动DOM操作可以大大提高开发效率。  



### 说下虚拟 DOM 的优缺点？  

优点：  
* 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；  
* 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；  
* 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。  

缺点：  
* 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。     



### 说下虚拟DOM的实现原理  

虚拟 DOM 的实现原理主要包括以下 3 部分：  
* 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；  
* diff 算法 — 比较两棵虚拟 DOM 树的差异；  
* patch 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。   



> 说到这里有可能会问你diff和patch算法的实现原理，这个自己下去看看源码吧



### 组件中写 name 选项有什么作用？  

* 项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤  
* DOM 做递归组件时需要调用自身 name  
* vue-devtools 调试工具里显示的组见名称是由vue中组件name决定的    



### nextTick是做什么的(以及原理)？  

Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改--刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 。  



`$nextTick`是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用`$nextTick`，则可以在回调中获取更新后的 DOM 



原理参考：[理解Vue中的 nextTick](https://juejin.cn/post/6844903962039025678)



### Vue组件中的data为什么必须是函数？  

因为JS本身的特性带来的  

因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响。  

如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响。而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。



### watch和computed有什么区别以及应用场景？  



参考：[Vue中watch、computed与methods的联系和区别](https://juejin.cn/post/6844904086349807624)    



### Vue的父组件和子组件生命周期钩子函数执行顺序？  

* 加载渲染过程    （父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted）  
* 子组件更新过程  （父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated）  
* 父组件更新过程  （父 beforeUpdate -> 父 updated）  
* 销毁过程  （父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed  ）  



### Vue组件间通信有哪几种方式？  

* props  
* $emit  
* $attr  
* $listener  
* provide  inject  (隔代通信)  
* $parent  $children  
* vuex    



详情参考：[Vue组件之间的数据传递(通信、交互)详解](https://juejin.cn/post/6844903911564787720)



### Vuex相关问题  

>  vuex是什么?  

vue框架中状态管理。  

>  vuex有哪几种属性?  

有五种，分别是 State、 Getters、Mutations 、Actions、 Module  

vuex的State特性  

* Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data  

* state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新  

* 它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中  

vuex的Getters特性  

* getters 可以对State进行计算操作，它就是Store的计算属性  

* 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用  

* 如果一个状态只在一个组件内使用，是可以不用getters  

vuex的Mutations特性  

* Actions 类似于 mutations，不同在于：Actions 提交的是 mutations，而不是直接变更状态;Actions 可以包含任意异步操作。  

>  不用Vuex会带来什么问题?  

* 可维护性会下降，想修改数据要维护三个地方;   

* 可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的;  

* 增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背；  



同步异步区别：    

1、流程顺序  “相应视图—>修改State”拆分成两部分，视图触发Action，Action再触发Mutation。      

2、角色定位  基于流程顺序，二者扮演不同的角色。    

* Mutation：专注于修改State，理论上是修改State的唯一途径。    

* Action：业务代码、异步请求。    

3、限制    

角色不同，二者有不同的限制。    

* Mutation：必须同步执行。    

* Action：可以异步，但不能直接操作State。   

Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。    



每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。**如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难**。



Vuex使用方法参考：[Vuex 的使用方法](https://juejin.cn/post/6844903902932893704)  

Vuex实现原理参考：[理解 vuex 实现原理](https://juejin.cn/post/6844903949938475022)  



### Vuex实现原理(和Redux对比)  

Redux 的核心概念

- action （同步action ，或借助 中间件 实现异步操作，action 不会改变 store，只是描述了怎么改变store）| mutation（用于同步操作） 、action（可用于异步操作，提交 mutation）
- reducer（纯函数，根据 action 和旧的 store 计算出新的 store
- store（单一数据源）

Vuex 的核心概念

- mutation（用于同步操作） 、action（可用于异步操作，提交 mutation）
- mutation里面直接修改 state
- state（单一数据源）  



其他：

i） Redux 提供了 `store.getState()` 这个 API 获取 store 树，还有 `store.subscribe(listener)` 订阅 store 的变化，当 store 改变时会调用监听器；Vuex 有一个 `getter` 的概念用于根据 state 派生出一些数据，像 Vue 的计算属性一样，当 state 改变时会重新计算出一个结果出来，提供给需要的组件。

ii） 对于大型项目，当应用状态数据过于复杂，可以划分状态，这样便于管理数据流向。Redux 可以通过 `combineReducers（）`结合各个组件的 reducer，各个组件可以单独管理自己的状态，最后合并为一个 reducer 用于生成一个 store；Vuex 这方面用 `Module` 这个概念划分 store，与 Redux 一样，可以多层嵌套子状态。

iii） 将状态数据绑定到视图：Redux 将状态映射到视图可以通过 React-redux 映射到 React 组件， 当然也可以直接使用 Redux 自己提供的 `store.subscribe()` 订阅 store 的改变，从而更新视图，因此 Redux 不仅仅可以用于 React，也可以用于其他框架如 Vue；而 Vuex 只能用于 Vue，它提供了 `mapState`、`mapAction`、`mapMutations` 等API 将 store 映射到 Vuex 各个组件，这个参考了 React-redux 的 `mapStateToProps`。  



**使用原则**  

Redux 的三大原则：

```text
（1）单一数据源（一个Redux应用只有一个store），也是单向的数据流；
（2）state只读（唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。）；
（3）使用纯函数（reducer）来修改state。
```

Vuex 的三大原则：

```text
a. 应用层级的状态应该集中到单个 store 对象中。
b. 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。
c. 异步逻辑都应该封装到 action 里面。
```



**处理异步操作**  

Redux 得益于 中间件机制，利用 redux-thunk `（redux-thunk 可以 dispatch 函数，这个函数用于生成 action，所以在这个函数里面我们可以进行异步操作，等异步的结果出来后再放在 action 里面将这个 action 用 dispatch 分发出去, 而这个函数被叫做 “action creator” ）`，可以将异步逻辑放在 action creator 里面，通过 action creator 做一个控制反转， 给 action creator 传入 dispatch 作为参数，于是就可以 dispatch action，`（原本是通过 dispatch 来分发 action ,现在是异步 action 即 action creator 掌握了控制权调用 dispatch，所以叫控制反转`），Redux 并没有创造单独的概念出来专门用于异步逻辑，它是利用了 Redux 自己实现的中间件机制，中间件从 dispatch 一个异步 action 到 action 到达 reducer 之间处理 action，在这期间通过异步操作得到的结果可以放到 action 里面再通过 dispatch 分发到 reducer，以前 dispatch 一个 action 之后，这个 action 回立即到达 reducer ，所以是同步 action，现在在 action creator 里面，我们通过控制反转，可以等待异步操作结果再生成 action 分发，所以叫做异步 action  



而 Vuex 是用 mutation 来对应 Redux 的 action，另外 Vuex 又创造了一个 action 来提交 mutation 并通过异步提交 mutation 来实现异步操作结果能够到达 state  



### Vue中$attrs使用时需要注意的点  

详细：
包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件。  

使用介绍
从官方介绍我们可以得出 `$attrs` 应用于父子传值场景下，子组件通过 `$attrs` 可以访问父组件传过来的所有属性，但需要注意的是**如果父组件所传的属性中有在子组件 `props` 中有过声明，那么该属性不会出现在 `$attrs` 对象中**。  



### Vue中为什么不能用a标签？  

因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以写的a标签是不起作用的，必须使用vue-router来进行管理。  



在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。**路由模块的本质就是建立起url和组件之间的映射关系**。 



### 说下vue-router吧  



> 怎么定义vue-router的动态路由以及如何获取传过来的动态参数？  

在router目录下的index.js文件中，对path属性加上/:id。
使用route对象的`params.id`获取数据  



参考：[Vue 路由传值(传参)详解](https://juejin.cn/post/6844903938752282631)  



> active-class是哪个组件的属性？  

vue-router模块的router-link组件，主要用来控制点击样式问题。    



> hash与history的区别？（重点）

vue-router 有 3 种路由模式：hash、history、abstract   
* hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；  
* history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；  
* abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.  

> hash模式    
>
> 我们先来认识下这位朋友 #，这个 # 就是hash符号，中文名哈希符或锚点，当然这在我们前端领域姑且这么称呼。
> 然后哈希符后面的值，我们称之为哈希值。OK，接下来我们继续分析他的原理。路由的哈希模式其实是利用了window可以监听`onhashchange`事件，也就是说你的url中的哈希值（#后面的值）如果有变化，前端是可以做到监听并做一些响应（搞点事情），这么一来，即使前端并没有发起http请求他也能够找到对应页面的代码块进行按需加载。

> history模式    
>
> 我们先介绍一下H5新推出的两个神器：pushState与replaceState
> 具体自行百度，简而言之，这两个神器的作用就是可以将url替换并且不刷新页面，好比挂羊头卖狗肉，http并没有去请求服务器该路径下的资源，一旦刷新就会暴露这个实际不存在的“羊头”，显示404。
> 那么如何去解决history模式下刷新报404的弊端呢，这就需要服务器端做点手脚，将不存在的路径请求重定向到入口文件（index.html），前后端联手，齐心协力做好“挂羊头卖狗肉”的完美特效。
> 至此，我们的前端路由在实现与展示效果上又更进了一步！
> 总之，pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应。

在history模式中，浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404了    

因此在线上部署基于 history API的单页面应用的时候，一定要后端配合支持才行，否则会出现大量的 404。
以最常用的 Nginx 为例，只需要在配置的 location / 中增加下面一行即可：  

``` 
try_files $uri /index.html
```



参考：[Vue的mode中 hash 与 history 的区别](https://juejin.cn/post/6844903902928879623)  

深入理解：[理解vue-router中(router-link router-view $router $route)实现原理](https://juejin.cn/post/6844903942128664584)



### slot知道吗？ 

slot就是Vue中的插槽，相当于先挖个坑，如果有组件的话，可以渲染到该位置  

插槽分类：  

* 内容插槽  
* 默认插槽  
* 具名插槽  
* 作用域插槽  
* 动态插槽



参考：[Vue 插槽(slot)使用(通俗易懂)](https://juejin.cn/post/6844903920037281805)



### Vue中如何动态绑定Class和Style？  



参考：[Vue Class与Style绑定](https://juejin.im/post/5da1990b51882518fa5a3877)  



### 怎样理解Vue的单向数据流？

所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。  

额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。    



### 直接给一个数组项赋值，Vue能检测到变化吗？  

由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：  
* 当你利用索引直接设置一个数组项时，例如：vm.items\[indexOfItem] = newValue  
* 当你修改数组的长度时，例如：vm.items.length = newLength    



> 追问：那么解决方法有哪些？  

* 使用Proxy(Vue3.x最重要的改动)  
* 使用`$set`  
* 改变数组的引用地址，相当于新数组    



### Vue.delete与delete的区别？  

delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。    

Vue.delete 直接删除了数组 改变了数组的键值。    



### Vue中data/computed相关问题  

> data中有属性A、B、C，计算属性D依赖A和B，那么在D中可以直接修改C的值吗？    
>
> 答：可以。     
>
> 如果我又在D中修改A，会出现问题吗？   
>
> 答：不会出现问题，会拿到新修改的值计算

> 计算属性A和B，如果A中用了B，B中用了A，会出现问题吗？如果出现问题，会造成什么影响？    
>
> 答：直接报错：超过最大调用堆栈大小

> 如果在data中定义了属性A，在计算属性也定义了A，会出现问题吗？     
>
> 答：会报警告，最后用的是data中的值，不用计算属性的值  

如果在data中这样定义，A的最终值是多少？  答：1

``` 
data() {
	this.A = 5
	return {
		A: 1,
		B: 2,
	}
},
```



### axios的优点有哪些？  

1.简单易用    

2.兼容性好    

3.通用性好    

4.稳定    

5.提供了一些并发请求    

6.支持拦截请求和响应    

7.安全，支持防御    

8.支持Promise    





### 如何取消Ajax请求？  

原生 Ajax 取消方式    

对于原生XHR对象来说，取消的ajax的关键是调用XHR对象的.abort()方法，请求被中断之后会触发 onabort 事件不会触发 error 事件  

``` javascript
let ajax = new XMLHttpRequest();
ajax.open("POST", "/api/sys/listTmallShop");
ajax.send(null);
ajax.onreadystatechange = function () {
    if (ajax.readyState === 4) {
        console.log(ajax.response);
    }
};
ajax.onabort = function () {
    console.log("请求被中断");
};
// 立即取消请求
ajax.abort();
```
jquery 取消方式    

由于 jquery 的 ajax 函数会返回一个原生的 xhr 对象所以可以通过这个对象调用原生的 abort 方法取消请求，取消之后会触发 error 事件  

``` javascript
var jp = $.ajax({
    type: "post",
    url: "/api/sys/listTmallShop",
    data: {
        platform: "TMALL",
        page: 1
    },
    success: function (data) {
        console.log("成功了");
        console.log(data);
    },
    error: function (err) {
        console.log("取消了");
        console.log(err);
    }
});
jp.abort();
```
axios 的取消方式    

axios的取消需要使用 CancelToken 获取取消令牌，并且用令牌标识单个请求，之后调用令牌的 cancel 即可取消  

``` javascript
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.post("/api/sys/listTmallShop", null, {
    cancelToken: source.token
}).catch(function (thrown) {
    if (axios.isCancel(thrown)) {
        console.log("取消了", thrown.message);
    } else {
        console.log("出错了");
    }
});

source.cancel("取消原因：老子愿意"); 
```
如果多个请求可以多次执行 CancelToken.source() 拿到多个 token对象   

除了以上的方式还有一种方式可以取消请求  

``` javascript
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // An executor function receives a cancel function as a parameter
    cancel = c;
  })
});

// cancel the request
cancel();
```



### 常用哪些方法解决跨域？  

* 前端配置vue.config.js（使用proxy）     
* 前端使用jsonp（只能处理get请求）
* 后端配置cors（配置各种头）  
* 后端配置nginx  



> jsonp的原理？  

使用了src标签没有跨域限制来实现的  

具体步骤：    

1. 创建一个script标签  
2. script的src属性设置接口地址  
3. 接口参数，必须要带一个自定义函数名，要不然后台无法返回数据   
4. 通过定义函数名去接受返回的数据  

```javascript
// 手写JSONP  
function jsonp(url, params = {}, callback) {
    // 处理json对象，拼接url
    params.callback = callback
    const paramsArr = []
    for (const key in params) {
        paramsArr.push(`${key}=${params[key]}`)
    }
    let script = document.createElement('script')
    script.src = `${url}?${paramsArr.join('&')}`
    document.body.appendChild(script)
    return new Promise((reslove, reject) => {
        window[callback] = res => {
            try {
                reslove(res)
            } catch(e) {
                reject(e)
            } finally {
                // 移除script
                script.parentNode.removeChild(script)
            }
        }
    })
}
```





### 说下vue.cli项目中src目录每个文件夹和文件的用法  

assets文件夹是放静态资源；    

components是放组件；    

router是定义路由相关的配置;    

view视图；    

app.vue是一个应用主组件；    

main.js是入口文件；     



### Vue打包后生成的.map文件有什么作用？

.map文件的生成与否可以在vue.config.js中配置，如下：  
```javascript
module.exports = {
    productionSourceMap: true,
}
```
当设置为true时，则打包后会生成.map文件，则前端服务把静态资源跑起来的时候，如果有报错信息，错误提示里可以直接定位到某某vue文件哪一行那一列出错了，可以直接点击查看。  
如果设置为false，则打包后不会生成.map文件，则前端服务把静态资源跑起来后，如果有报错信息，则错误提示里直接压缩后的.js文件，无法定位到是哪个vue文件，哪一行出错了。   



### Vue3.0有没有了解过？    

**性能提升**  

- 打包大小减少41%
- 初次渲染快55%, 更新渲染快133%
- 内存减少54%
- **使用Proxy代替defineProperty实现数据响应式**
- **重写虚拟DOM的实现和Tree-Shaking**  



**新增特性**  

- **Composition (组合) API**
- setup
  - ref 和 reactive
  - computed 和 watch
  - 新的生命周期函数
  - provide与inject
  - ...
- 新组件
  - Fragment - 文档碎片
  - Teleport - 瞬移组件的位置
  - Suspense - 异步加载组件的loading界面
- 其它API更新
  - 全局API的修改
  - 将原来的全局API转移到应用对象
  - 模板语法变化

----------

关于Vue 3.0，大致说了三个点：  

* 第一个是关于提出的新API setup()函数，setup创建组件实例时，在初始组件解析后立即调用。在生命周期方面，它在beforeCreate之前被调用（2.x）
* 第二个说了对于Typescript的支持  
* 第三个详细说了下关于Proxy代替带来的性能上的提升，因为传统的原型链拦截的方法，无法检测对象及数组的一些更新操作，但使用Proxy又带来了浏览器兼容问题。  



一些小东西：  

* 调整v-if与v-for的优先级  
* 可以没有根标签  
* 默认导出一个组件  
* ...................  



### Proxy与Object.defineProperty优劣对比  

Proxy 的优势如下:  
* Proxy 可以直接监听对象而非属性；  
* Proxy 可以直接监听数组的变化；  
* Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是Object.defineProperty 不具备的；  
* Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；  
* Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；   



Object.defineProperty 的优势如下:  

* 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。





### Vue项目中怎么做性能优化    

列举一些，自己看着说，语言丰富以下即可  

* data优化（对象层级不要过深，不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据））  
* 巧妙利用指令v-if(show)，使用v-for要绑定key   
* 路由懒加载  
* 动态导入组件  
* 图片懒加载  
* 第三方模块按需导入  
* 骨架屏  
* PWA缓存  
* 预渲染  
* 缓存和压缩  
* HTTP优化  
* computed 和 watch 区分使用场景
* 大数据列表和表格性能优化-虚拟列表/虚拟表格
* 防止内部泄漏，组件销毁后把全局变量和事件销毁
* 适当采用 keep-alive 缓存组件
* 防抖、节流运用
* 服务端渲染 SSR or 预渲染   
* 文件压缩，减小资源大小  
* 小图片转base64，减少请求  
* 雪碧图，减少请求  
* 渲染优化（重绘、回流）  
* 减少cookie的使用，减少请求携带大小    



这位大佬写的非常好，可以参考一下：[写给中高级前端关于性能优化的9大策略和6大指标](https://juejin.cn/post/6981673766178783262)  





### uniApp相关    

**声明一点：因为uniApp跨的端太多，所以兼容性不好**



>  uniApp中的setData了解过吗？  

其实和React中的setState差不多，看后面setState的讲解  



> uniApp的声明周期变动    



**uniApp应用生命周期函数**

| 函数名               | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| onLaunch             | 当uni-app 初始化完成时触发（全局只触发一次）                 |
| onShow               | 当 uni-app 启动，或从后台进入前台显示                        |
| onHide               | 当 uni-app 从前台进入后台                                    |
| onError              | 当 uni-app 报错时触发                                        |
| onUniNViewMessage    | 对 nvue 页面发送的数据进行监听，可参考 [vue 向 vue 通讯](https://link.juejin.cn?target=https%3A%2F%2Funiapp.dcloud.io%2Fuse-weex%3Fid%3Dnvue-%E5%90%91-vue-%E9%80%9A%E8%AE%AF) |
| onUnhandledRejection | 对未处理的 Promise 拒绝事件监听函数（2.8.1+）                |
| onPageNotFound       | 页面不存在监听函数                                           |
| onThemeChange        | 监听系统主题变化                                             |

注意：

- 应用生命周期**仅可在App.vue中全局监听**，在其它页面监听无效。


**uniApp页面生命周期函数**

| 函数名                              | 说明                                                         | 平台差异说明                                        |
| ----------------------------------- | ------------------------------------------------------------ | --------------------------------------------------- |
| onLoad                              | 监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），[参考示例](https://link.juejin.cn?target=https%3A%2F%2Funiapp.dcloud.io%2Fapi%2Frouter%3Fid%3Dnavigateto) |                                                     |
| onShow                              | 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 |                                                     |
| onReady                             | 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 |                                                     |
| onHide                              | 监听页面隐藏                                                 |                                                     |
| onUnload                            | 监听页面卸载                                                 |                                                     |
| onResize                            | 监听窗口尺寸变化                                             | 5+App、微信小程序                                   |
| onPullDownRefresh                   | 监听用户下拉动作，一般用于下拉刷新，[参考示例](https://link.juejin.cn?target=https%3A%2F%2Funiapp.dcloud.io%2Fapi%2Fui%2Fpulldown) |                                                     |
| onReachBottom                       | 页面上拉触底事件的处理函数                                   |                                                     |
| onTabItemTap                        | 点击 tab 时触发，参数为Object                                | 微信小程序、百度小程序、H5、5+App（自定义组件模式） |
| onShareAppMessage                   | 用户点击右上角分享                                           | 微信小程序、百度小程序、头条小程序、支付宝小程序    |
| onPageScroll                        | 监听页面滚动，参数为Object                                   | 5+ App、H5                                          |
| onNavigationBarButtonTap            | 监听原生标题栏按钮点击事件，参数为Object                     |                                                     |
| onBackPress                         | 监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：[onBackPress 详解](https://link.juejin.cn?target=https%3A%2F%2Fask.dcloud.net.cn%2Farticle%2F35120) | 5+ App、H5                                          |
| onNavigationBarSearchInputChanged   | 监听原生标题栏搜索输入框输入内容变化事件                     | 5+ App、H5                                          |
| onNavigationBarSearchInputConfirmed | 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。 | 5+ App、H5                                          |
| onNavigationBarSearchInputClicked   | 监听原生标题栏搜索输入框点击事件                             | 5+ App、H5                                          |

注意：

- 页面生命周期**仅在page页面有效**，而单独封装的组件中【页面周期无效】，但是Vue的生命周期依然有效 【Vue的生命周期在任何地方都是有效的】
- 推荐使用uni-app里面的 `onReady` 代替 vue 里面的 `mounted`
- 推荐使用uni-app里面的 `onLoad` 代替 vue 里面的 `created`





参考：[uniApp与vue生命周期对比](https://juejin.cn/post/6917438354938134536)  





## React  



### React有哪些优点和局限呢？  

优点：

1. 它提高了应用的性能
2. 可以方便地在客户端和服务器端使用
3. 由于 JSX，代码的可读性很好
4. React 很容易与 Meteor，Angular 等其他框架集成
5. 使用React，编写UI测试用例变得非常容易



局限：  

1. React 只是一个库，而不是一个完整的框架
2. 它的库非常庞大，需要时间来理解
3. 新手程序员可能很难理解
4. 编码变得复杂，因为它使用内联模板和 JSX



### 说说你对React事件机制的理解    

`React`基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等

在`React`中这套事件机制被称之为合成事件，合成事件是 `React`模拟原生 `DOM`事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器。  



事件监听输出顺序：  

1. 原生事件：子元素 DOM 事件监听！ 
2. 原生事件：父元素 DOM 事件监听！ 
3. React 事件：子元素事件监听！ 
4. React 事件：父元素事件监听！ 
5. 原生事件：document DOM 事件监听！ 



`React`事件机制总结如下：

- React 上注册的事件最终会绑定在document这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)
- React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。
- React 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback
- React 有一套自己的合成事件 SyntheticEvent



参考：  [说说对React事件机制的理解?](https://blog.csdn.net/weixin_44475093/article/details/118384067)  



### 说说React生命周期有哪些不同阶段？每个阶段对应的方法是？  



**v16.0之前**  

![reactLife160](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/reactLife160.png)







**v16.4之后**

![reactLife164](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/reactLife164.png)





参考：[React 生命周期(v16.0前 和 v16.4)](https://juejin.cn/post/6844903981412515847)





### React的hooks的执行原理？  

> 什么是hooks?

`Hook` 是 React 16.8 的新增特性。它可以让你在不编写 `class` 的情况下使用 `state` 以及其他的 `React` 特性

至于为什么引入`hook`，官方给出的动机是解决长时间使用和维护`react`过程中常遇到的问题，例如：

- 难以重用和共享组件中的与状态相关的逻辑
- 逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面
- 类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题
- 由于业务变动，函数组件不得不改为类组件等等

在以前，函数组件也被称为无状态的组件，只负责渲染的一些工作

因此，现在的函数组件也可以是有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理



> 都有哪些hooks?   

* useState  
* useEffect

- useReducer
- useCallback
- useMemo
- useRef



> hooks解决了什么问题：  

`hooks`能够更容易解决状态相关的重用的问题：  

- 每调用useHook一次都会生成一份独立的状态
- 通过自定义hook能够更好的封装我们的功能

* 编写`hooks`为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅  
* 使函数组件的功能得到了扩充，拥有了类组件相似的功能





执行原理感觉问的太深，了解即可  

参考：[轻松掌握React Hooks底层实现原理](https://segmentfault.com/a/1190000038768433)





### React的hooks怎么模拟生命周期？  



使用 hooks 模拟 componentDidMount  

``` javascript
function Example() {
  // 当我们指定第二个参数为空数组就可以代替我们类组件中的componentDidMount
  useEffect(() => {
  	console.log('Did mount!');
  }, []);  
  return <div></div>;
}
```
使用 hooks 模拟 componentDidUpdate  

``` 
function Example() {
  // 当我们不指定第二个参数的时候就可以代替我们类组件中的componentDidUpdate
  useEffect(() => {
  	console.log('Did update!');
  });  
  return <div></div>;
}
```

使用 hooks 模拟 componentWillUnmount  

``` javascript
function Example() {
  // 当我们不指定第二个参数的同时并在第一个参数中返回一个函数就可以代替我们类组件中的componentWillUnmount
  useEffect(() => {
  	return () => {
	  console.log('will unmount');  
	}
  });  
  return <div></div>;
}
```
想通过useEffect模拟componentDidUpdate生命周期，而去掉初次渲染时调用的 componentDidMount     

因为初次渲染只会发生一次，可以使用useRef立一个flag解决：

``` javascript
let mounting = useRef(true);
useEffect(() => {
	if (mounting.current) {
		console.log("初次")
		mounting.current = false;
		return 
	}
	console.log("DidUpdated")
});
```

useEffect 拥有两个参数，第一个参数作为回调函数会在浏览器布局和绘制完成后调用，因此它不会阻碍浏览器的渲染进程。第二个参数是一个数组
* 当数组存在并有值时，如果数组中的任何值发生更改，则每次渲染后都会触发回调。  
* 当它不存在时，每次渲染后都会触发回调。  
* 当它是一个空列表时，回调只会被触发一次，类似于 componentDidMount。  
* 当不指定第二个参数的同时并在第一个参数中返回一个函数就可以代替我们类组件中的componentWillUnmount  



### React函数组件和类组件区别以及使用场景  

1. 语法上的区别：

函数式组件是一个纯函数，它是需要接受props参数并且返回一个React元素就可以了。类组件是需要继承React.Component的，而且class组件需要创建render并且返回React元素，语法上来讲更复杂。

2. 调用方式

函数式组件可以直接调用，返回一个新的React元素；类组件在调用时是需要创建一个实例的，然后通过调用实例里的render方法来返回一个React元素。

3. 状态管理

函数式组件没有状态管理，类组件有状态管理。  

4. 生命周期  

类组件有生命周期，可以处理一些较为复杂的逻辑，函数组件没有声明周期，需要模拟

5. 使用场景

类组件没有具体的要求。函数式组件一般是用在大型项目中来分割大组件（函数式组件不用创建实例，所以更高效），一般情况下能用函数式组件就不用类组件，提升效率。



### React怎么保存当前组件的状态？  

**手动保存状态**  
手动保存状态即通过 React 提供的 componentWillUnmount 生命周期通过 redux 之类的状态管理库对数据进行保存，通过 componentDidMount 生命周期进行数据恢复，这也是目前最常见的解决方式，这里不展开讨论。

**通过路由实现状态保存**
由于状态丢失的主要原因是由于路由切换时导致组件被卸载，如果是这样，是否只需要保证组件不被卸载，或者在组件卸载之前将数据状态保存就可以解决我们的问题了，事实上目前社区的相关实现也正是这样。

核心思路：`路由匹配 -> 组件渲染 -> 切换路由 -> 组件卸载 => 路由匹配 -> 组件渲染 -> 切换路由 -> 组件隐藏`  
| 库/功能           | [react-keep-alive](https://github.com/StructureBuilder/react-keep-alive) | [react-keeper](https://github.com/vifird/react-keeper) | [react-router-cache-route](https://github.com/CJY0208/react-router-cache-route) | [react-activation](https://github.com/CJY0208/react-activation/) |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 实现思路          | 将 KeepAlive 的组件藏于其 Provider 中，保证其不会被卸载 -    | 基于 react-router 完全实现一个自定义的路由库           | 改写 react-router 库的 Route 组件，控制渲染行为，使其不被卸载 | 同 react-keep-alive                                          |
| GitHub star       | 407                                                          | 708                                                    | 474                                                          | 217                                                          |
| NPM download      | < 300                                                        | < 200                                                  | ~ 3k                                                         | < 150                                                        |
| 使用方式          | KeepLive                                                     | CacheLink                                              | CacheRoute、CacheSwitch                                      | KeepAlive                                                    |
| Class 生命周期    | componentDidActivate componentWillUnactivate                 | -                                                      | componentDidCache componentDidRecover                        | componentDidActivate componentWillUnactivate                 |
| Function 生命周期 | useKeepAliveEffect                                           | -                                                      | -                                                            | useActivate useUnactivate                                    |
| 恢复滚动位置      | 支持                                                         | 支持                                                   | 支持                                                         | 支持                                                         |
| 缓存控制          | 支持                                                         | -                                                      | 支持（不友好）                                               | 支持                                                         |
| 总结              | ★★★★                                                         | ★★                                                     | ★★                                                           | ★★★★                                                         |



### React中的state和props有什么区别？  

**state**  

一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是`state`，一般在 `constructor` 中初始化

当需要修改里面的值的状态需要通过调用`setState`来改变，从而达到更新组件内部数据的作用，并且重新调用组件`render`方法。    

`setState`还可以接受第二个参数，它是一个函数，会在`setState`调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成



**props**

`React`的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件

组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是`props`，所以可以把`props`理解为从外部传入组件内部的数据

`react`具有单向数据流的特性，所以他的主要作用是从父组件向子组件中传递数据

`props`除了可以传字符串，数字，还可以传递对象，数组甚至是回调函数。  



在子组件中，`props`在内部不可变的，如果想要改变它看，只能通过外部组件传入新的`props`来重新渲染子组件，否则子组件的`props`和展示形式不会改变  



**总结：**  

相同点：

- 两者都是 JavaScript 对象
- 两者都是用于保存信息
- props 和 state 都能触发渲染更新

区别：

- props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化
- props 在组件内部是不可修改的，但 state 在组件内部可以进行修改
- state 是多变的、可以修改



### React组件之间如何通信？  

React 中组件间的通信有以下几种情况：

- 父组件向子组件通信，可以通过 props 方式传递数据；也可以通过 ref 方式传递数据；
- 子组件向父组件通信，通过回调函数方式传递数据；
- 父组件向后代所有组件传递数据，如果组件层级过多，通过 props 的方式传递数据很繁琐，可以通过 Context.Provider 的方式；
- 一个数据源实现跨组件通信，通过指定 contextType 的方式来实现；
- 多个数据源实现跨组件通信，使用 Context.Consumer 方式实现；  
- 使用第三方库管理状态，例如Redux



> 一般来说，使用props、回调和Redux最多  



参考：[React 组件通信](https://blog.csdn.net/Charissa2017/article/details/105746685)  



### 说说你对Redux的理解？都有哪些方法和中间件？  

`redux`就是一个实现状态集中管理的容器，遵循三大基本原则：

- 单一数据源

整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中

- State 是只读的

唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象

- 使用纯函数来执行修改

为了描述 action 如何改变 state tree ，你需要编写 reducers



**工作原理：**  

`redux`要求我们把数据都放在 `store`公共存储空间

一个组件改变了 `store` 里的数据内容，其他组件就能感知到 `store`的变化，再来取数据，从而间接的实现了这些数据传递的功能

工作流程图如下所示：  

![Mredux](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Mredux.png)

根据流程图，可以想象，`React Components` 是借书的用户， `Action Creactor` 是借书时说的话(借什么书)， `Store` 是图书馆管理员，`Reducer` 是记录本(借什么书，还什么书，在哪儿，需要查一下)， `state` 是书籍信息

整个流程就是借书的用户需要先存在，然后需要借书，需要一句话来描述借什么书，图书馆管理员听到后需要查一下记录本，了解图书的位置，最后图书馆管理员会把这本书给到这个借书人

转换为代码是，`React Components` 需要获取一些数据, 然后它就告知 `Store` 需要获取数据，这就是就是 `Action Creactor` , `Store` 接收到之后去 `Reducer` 查一下， `Reducer` 会告诉 `Store` 应该给这个组件什么数据



> 优雅的使用redux  

```txt
|--src
    |-- store                 Redux目录
        |-- actions.js
        |-- index.js
        |-- reducers.js
        |-- state.js
    |-- components      组件目录
        |-- Test.jsx
    |-- App.js               项目入口
```





实现原理、常用中间件，参考：[Redux 源码剖析](https://juejin.cn/post/6844903983299952648)





### 说说React中的setState的执行机制  

一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是`state`

当需要修改里面的值的状态需要通过调用`setState`来改变，从而达到更新组件内部数据的作用  



**如果你想更新视图，则必须调用setState方法，这样React就知道你修改数据了，需要更新视图，否则不会触发视图的更新**  



> 经典问题：setState是同步的，还是异步的？  

在使用`setState`更新数据的时候，`setState`的更新类型分成：

- 异步更新
- 同步更新  



**异步更新：**  

举出一个例子：

```jsx
changeText() {
  this.setState({
    message: "你好啊"
  })
  console.log(this.state.message); // Hello World
}
```

从上面可以看到，最终打印结果为`Hello world`，并不能在执行完`setState`之后立马拿到最新的`state`的结果

如果想要立刻获取更新后的值，在第二个参数的回调中更新后会执行

```jsx
changeText() {
  this.setState({
    message: "你好啊"
  }, () => {
    console.log(this.state.message); // 你好啊
  });
}
```



**同步更新：**  

同样先给出一个在`setTimeout`中更新的例子：

```jsx
changeText() {
  setTimeout(() => {
    this.setState({
      message: "你好啊
    });
    console.log(this.state.message); // 你好啊
  }, 0);
}
```

上面的例子中，可以看到更新是同步

再来举一个原生`DOM`事件的例子：

```jsx
componentDidMount() {
  const btnEl = document.getElementById("btn");
  btnEl.addEventListener('click', () => {
    this.setState({
      message: "你好啊"
    });
    console.log(this.state.message); // 你好啊
  })
}
```



**总结：**  

- 在组件生命周期或React合成事件中，setState是异步
- 在setTimeout或者原生dom事件中，setState是同步(由于是同步的操作，所以并不会出现覆盖现象)  





### React中的key有什么作用？  

>  和Vue中一样，没什么区别

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>key的作用</title>
</head>
<body>
<div id="test"></div>
<!-- 引入react核心库(自己下载引一下) -->
<script type="text/javascript" src="../js/react.development.js"></script>
<!-- 引入react-dom -->
<script type="text/javascript" src="../js/react-dom.development.js"></script>
<!-- 引入babel -->
<script type="text/javascript" src="../js/babel.min.js"></script>

<script type="text/babel">
        /*
   经典面试题:
      1). react/vue中的key有什么作用？（key的内部原理是什么？）
      2). 为什么遍历列表时，key最好不要用index?
      
                        1. 虚拟DOM中key的作用：
                                        1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。

                                        2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 
                                                                                                随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：

                                                                        a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：
                                                                                                (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM
                                                                                                (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM

                                                                        b. 旧虚拟DOM中未找到与新虚拟DOM相同的key
                                                                                                根据数据创建新的真实DOM，随后渲染到到页面
                                                                        
                        2. 用index作为key可能会引发的问题：
                                                                1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:
                                                                                                会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。

                                                                2. 如果结构中还包含输入类的DOM：
                                                                                                会产生错误DOM更新 ==> 界面有问题。
                                                                                                
                                                                3. 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，
                                                                        仅用于渲染列表用于展示，使用index作为key是没有问题的。
                                        
                        3. 开发中如何选择key?:
                                                                1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。
                                                                2.如果确定只是简单的展示数据，用index也是可以的。
   */
        
        /* 
                慢动作回放----使用index索引值作为key

                        初始数据：
                                        {id:1,name:'小张',age:18},
                                        {id:2,name:'小李',age:19},
                        初始的虚拟DOM：
                                        <li key=0>小张---18<input type="text"/></li>
                                        <li key=1>小李---19<input type="text"/></li>

                        更新后的数据：
                                        {id:3,name:'小王',age:20},
                                        {id:1,name:'小张',age:18},
                                        {id:2,name:'小李',age:19},
                        更新数据后的虚拟DOM：
                                        <li key=0>小王---20<input type="text"/></li>
                                        <li key=1>小张---18<input type="text"/></li>
                                        <li key=2>小李---19<input type="text"/></li>

        -----------------------------------------------------------------

        慢动作回放----使用id唯一标识作为key

                        初始数据：
                                        {id:1,name:'小张',age:18},
                                        {id:2,name:'小李',age:19},
                        初始的虚拟DOM：
                                        <li key=1>小张---18<input type="text"/></li>
                                        <li key=2>小李---19<input type="text"/></li>

                        更新后的数据：
                                        {id:3,name:'小王',age:20},
                                        {id:1,name:'小张',age:18},
                                        {id:2,name:'小李',age:19},
                        更新数据后的虚拟DOM：
                                        <li key=3>小王---20<input type="text"/></li>
                                        <li key=1>小张---18<input type="text"/></li>
                                        <li key=2>小李---19<input type="text"/></li>


         */
        class Person extends React.Component{

                state = {
                        persons:[
                                {id:1,name:'小张',age:18},
                                {id:2,name:'小李',age:19},
                        ]
                }

                add = ()=>{
                        const {persons} = this.state
                        const p = {id:persons.length+1,name:'小王',age:20}
                        this.setState({persons:[p,...persons]})
                }

                render(){
                        return (
                                <div>
                                        <h2>展示人员信息</h2>
                                        <button onClick={this.add}>添加一个小王</button>
                                        <h3>使用index（索引值）作为key</h3>
                                        <ul>
                                                {
                                                        this.state.persons.map((personObj,index)=>{
                                                                return <li key={index}>{personObj.name}---{personObj.age}<input type="text"/></li>
                                                        })
                                                }
                                        </ul>
                                        <hr/>
                                        <hr/>
                                        <h3>使用id（数据的唯一标识）作为key</h3>
                                        <ul>
                                                {
                                                        this.state.persons.map((personObj)=>{
                                                                return <li key={personObj.id}>{personObj.name}---{personObj.age}<input type="text"/></li>
                                                        })
                                                }
                                        </ul>
                                </div>
                        )
                }
        }

        ReactDOM.render(<Person/>,document.getElementById('test'))
</script>
</body>
</html>
```





### 谈谈你对React中refs的理解？  

`Refs` 在计算机中称为弹性文件系统（英语：Resilient File System，简称ReFS）

`React` 中的 `Refs`提供了一种方式，允许我们访问 `DOM`节点或在 `render`方法中创建的 `React`元素

本质为`ReactDOM.render()`返回的组件实例，如果是渲染组件则返回的是组件实例，如果渲染`dom`则返回的是具体的`dom`节点  



创建`ref`的形式有三种：

- 传入字符串，使用时通过 this.refs.传入的字符串的格式获取对应的元素
- 传入对象，对象是通过 React.createRef() 方式创建出来，使用时获取到创建的对象中存在 current 属性就是对应的元素
- 传入函数，该函数会在 DOM 被挂载时进行回调，这个函数会传入一个 元素对象，可以自己保存，使用时，直接拿到之前保存的元素对象即可
- 传入hook，hook是通过 useRef() 方式创建，使用时通过生成hook对象的 current 属性就是对应的元素



**如果`ref`设置的组件为一个类组件的时候，`ref`对象接收到的是组件的挂载实例**



**应用场景：**  

在某些情况下，我们会通过使用`refs`来更新组件，但这种方式并不推荐，更多情况我们是通过`props`与`state`的方式进行去重新渲染子元素

过多使用`refs`，会使组件的实例或者是`DOM`结构暴露，违反组件封装的原则  



但下面的场景使用`refs`非常有用：

- 对Dom元素的焦点控制、内容选择、控制
- 对Dom元素的内容设置及媒体播放
- 对Dom元素的操作和对组件实例的操作
- 集成第三方 DOM 库



### 说说你对受控组件和非受控组件的理解？  

**受控组件**：简单来讲，就是受我们控制的组件，组件的状态全程响应外部数据

举个简单的例子：

```jsx
class TestComponent extends React.Component {
  constructor (props) {
    super(props);
    this.state = { username: 'lindaidai' };
  }
  render () {
    return <input name="username" value={this.state.username} />
  }
}
```

这时候当我们在输入框输入内容的时候，会发现输入的内容并无法显示出来，也就是`input`标签是一个可读的状态

这是因为`value`被`this.state.username`所控制住。当用户输入新的内容时，`this.state.username`并不会自动更新，这样的话`input`内的内容也就不会变了

如果想要解除被控制，可以为`input`标签设置`onChange`事件，输入的时候触发事件函数，在函数内部实现`state`的更新，从而导致`input`框的内容页发现改变

因此，受控组件我们一般需要初始状态和一个状态更新事件函数





**非受控组件**：简单来讲，就是不受我们控制的组件

一般情况是在初始化的时候接受外部数据，然后自己在内部存储其自身状态

当需要时，可以使用`ref` 查询 `DOM`并查找其当前值，如下：

```jsx
import React, { Component } from 'react';

export class UnControll extends Component {
  constructor (props) {
    super(props);
    this.inputRef = React.createRef();
  }
  handleSubmit = (e) => {
    console.log('我们可以获得input内的值为', this.inputRef.current.value);
    e.preventDefault();
  }
  render () {
    return (
      <form onSubmit={e => this.handleSubmit(e)}>
        <input defaultValue="lindaidai" ref={this.inputRef} />
        <input type="submit" value="提交" />
      </form>
    )
  }
}
```



**总结：**  

* 受控组件表单数据由state管理，非受控组件表单数据由DOM节点管理；  
* 受控组件表单数据变更具有实时性，具有双向数据绑定特性，非受控组件表单数据是一次性的，需要时读取，受控组件能帮助我们更好的控制表单元素。



**应用场景：**  

* 受控组件：一次性取值、提交时验证、即时验证、有条件的禁用按钮、强制输入格式、动态输入......  
* 非受控组件：一次性取值、提交时验证  



### 说说你对高阶组件的理解？  

高阶函数（Higher-order function），至少满足下列一个条件的函数

- 接受一个或多个函数作为输入
- 输出一个函数  



**高阶组件的主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好地被复用**  



在使用高阶组件的同时，一般遵循一些约定：  

- props 保持一致
- 你不能在函数式（无状态）组件上使用 ref 属性，因为它没有实例
- 不要以任何方式改变原始组件 WrappedComponent
- 透传不相关 props 属性给被包裹的组件 WrappedComponent
- 不要再 render() 方法中使用高阶组件
- 使用 compose 组合高阶组件
- 包装显示名字以便于调试  



**应用场景：**  

高阶组件能够提高代码的复用性和灵活性，在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，如权限控制、日志记录、数据校验、异常处理、统计上报等  





### 说说你对React-Router的理解？  

`react-router`等前端路由的原理大致相同，可以实现**无刷新的条件下切换显示不同的页面**

路由的本质就是页面的`URL`发生改变时，页面的显示结果可以根据`URL`的变化而变化，但是页面不会刷新

因此，可以通过前端路由可以实现单页(SPA)应用



`react-router-dom`的常用`API`和组件：  

- BrowserRouter、HashRouter
- Route
- Link、NavLink
- switch
- redirect



剩下的和Vue一样，说下hash和history即可  



参考：[React 路由的使用方法](https://juejin.cn/post/6844903975897006093)  



### 说下React的render在什么情况下会触发？   



在`React` 中，类组件只要执行了 `setState` 方法，就一定会触发 `render` 函数执行，函数组件使用`useState`更改状态不一定导致重新`render`

组件的`props` 改变了，不一定触发 `render` 函数的执行，但是如果 `props` 的值来自于父组件或者祖先组件的 `state`

在这种情况下，父组件或者祖先组件的 `state` 发生了改变，就会导致子组件的重新渲染

所以，一旦执行了`setState`就会执行`render`方法，`useState` 会判断当前值有无发生改变确定是否执行`render`方法，一旦父组件发生渲染，子组件也会渲染





### 说说你对React新提出的Fiber的理解  

**问题：**  

`JavaScript`引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待

如果 `JavaScript` 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿

而这也正是 `React 15` 的 `Stack Reconciler`所面临的问题，当 `React`在渲染组件时，从开始到渲染完成整个过程是一气呵成的，无法中断

如果组件较大，那么`js`线程会一直执行，然后等到整棵`VDOM`树计算完成后，才会交给渲染的线程

这就会导致一些用户交互、动画等任务无法立即得到处理，导致卡顿的情况  



**Fiber是什么？**  

React Fiber 是 Facebook 花费两年余时间对 React 做出的一个重大改变与优化，是对 React 核心算法的一次重新实现。从Facebook在 React Conf 2017 会议上确认，React Fiber 在React 16 版本发布

在`react`中，主要做了以下的操作：

- 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务
- 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行
- dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行

从架构角度来看，`Fiber` 是对 `React`核心算法（即调和过程）的重写

从编码角度来看，`Fiber`是 `React`内部所定义的一种数据结构，它是 `Fiber`树结构的节点单位，也就是 `React 16` 新架构下的虚拟`DOM`

一个 `fiber`就是一个 `JavaScript`对象，包含了元素的信息、该元素的更新操作队列、类型  



**如何解决问题：**  

`Fiber`把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行

即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 `React Element` 对应的 `Fiber`节点

实现的上述方式的是`requestIdleCallback`方法

`window.requestIdleCallback()`方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应

首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。

该实现过程是基于 `Fiber`节点实现，作为静态的数据结构来说，每个 `Fiber` 节点对应一个 `React element`，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。

作为动态的工作单元来说，每个 `Fiber` 节点保存了本次更新中该组件改变的状态、要执行的工作。

每个 Fiber 节点有个对应的 `React element`，多个 `Fiber`节点根据如下三个属性构建一颗树：

```javascript
// 指向父级Fiber节点
this.return = null
// 指向子Fiber节点
this.child = null
// 指向右边第一个兄弟Fiber节点
this.sibling = null
```

通过这些属性就能找到下一个执行目标



### 说下React从JSX转变为真实DOM的过程  



首先，JSX通过babel转化成`React.createElement`这种形式  

在转化过程中，`babel`在编译时会判断 JSX 中组件的首字母：

- 当首字母为小写时，其被认定为原生 `DOM` 标签，`createElement` 的第一个变量被编译为字符串
- 当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象

最终都会通过`RenderDOM.render(...)`方法进行挂载，如下：  

```react
ReactDOM.render(<App />,  document.getElementById("root"));
```





接着`React.createElement`调用时会传⼊标签类型`type`，标签属性`props`及若干子元素`children`，作用是生成一个虚拟`Dom`对象  

`createElement`会根据传入的节点信息进行一个判断：

- 如果是原生标签节点， type 是字符串，如div、span
- 如果是文本节点， type就没有，这里是 TEXT
- 如果是函数组件，type 是函数名
- 如果是类组件，type 是类名

虚拟`DOM`会通过`ReactDOM.render`进行渲染成真实`DOM`，使用方法如下： 

```react
ReactDOM.render(element, container[, callback])
```

当首次调用时，容器节点里的所有 `DOM` 元素都会被替换，后续的调用则会使用 `React` 的 `diff`算法进行高效的更新

如果提供了可选的回调函数`callback`，该回调将在组件被渲染或更新之后被执行  



在`react`源码中，虚拟`Dom`转化成真实`Dom`整体渲染流程如下所示：

- 使用React.createElement或JSX编写React组件，实际上所有的 JSX 代码最后都会转换成React.createElement(...) ，Babel帮助我们完成了这个转换的过程。
- createElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个虚拟DOM对象
- ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM







### React常用的性能优化手段有哪些？  



- 避免使用内联函数
- 使用 React Fragments 避免额外标记
- 使用 Immutable
- 懒加载组件
- 事件绑定方式
- 服务端渲染



`react`常见的性能优化可以分成三个层面：

- 代码层面
- 工程层面

* 框架机制层面



### 谈谈你对React中SSR的理解？  

服务端渲染是数据与模版组成的html，即 HTML = 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;

**SSR的优势：**

- 对SEO友好
- 所有的模版、图片等资源都存在服务器端
- 一个html返回所有数据
- 减少HTTP请求
- 响应快、用户体验好、首屏渲染快



**SSR的局限：**

1. 服务端压力较大

本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源;

2. 开发条件受限

在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;

3. 学习成本相对较高  

除了对webpack、MVVM框架要熟悉，还需要掌握node、 Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。




### Vue与React有什么区别呢？  

**1、监听数据变化的实现原理不同**

Vue通过 getter/setter以及一些函数的劫持，能精确知道数据变化。

React默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的VDOM的重新渲染。为什么React不精确监听数据变化呢？这是因为Vue和React设计理念上的区别，Vue使用的是可变数据，而React更强调数据的不可变，两者没有好坏之分，Vue更加简单，而React构建大型应用的时候更加健壮。  



**2、数据流的不同**  

Vue1.0中可以实现两种双向绑定：父子组件之间，props可以双向绑定；组件与DOM之间可以通过v-model双向绑定。Vue2.x中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且Vue2.x已经不鼓励组件对自己的 props进行任何修改了。

React一直不支持双向绑定，提倡的是单向数据流，称之为onChange/setState()模式。不过由于我们一般都会用Vuex以及Redux等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。  



**3、HoC和mixins**  

Vue组合不同功能的方式是通过mixin，Vue中组件是一个被包装的函数，并不简单的就是我们定义组件的时候传入的对象或者函数。比如我们定义的模板怎么被编译的？比如声明的props怎么接收到的？这些都是vue创建组件实例的时候隐式干的事。由于vue默默帮我们做了这么多事，所以我们自己如果直接把组件的声明包装一下，返回一个HoC，那么这个被包装的组件就无法正常工作了。

React组合不同功能的方式是通过HoC(高阶组件）。React最早也是使用mixins的，不过后来他们觉得这种方式对组件侵入太强会导致很多问题，就弃用了mixinx转而使用HoC。高阶组件本质就是高阶函数，React的组件是一个纯粹的函数，所以高阶函数对React来说非常简单。  



**4、组件通信的区别**  

Vue中有三种方式可以实现组件通信：父组件通过props向子组件传递数据或者回调，虽然可以传递回调，但是我们一般只传数据；子组件通过事件向父组件发送消息；通过V2.2.0中新增的provide/inject来实现父组件向子组件注入数据，可以跨越多个层级。

React中也有对应的三种方式：父组件通过props可以向子组件传递数据或者回调；可以通过 context 进行跨层级的通信，这其实和 provide/inject 起到的作用差不多。React 本身并不支持自定义事件，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数，但Vue更倾向于使用事件。在React中我们都是使用回调函数的，这可能是他们二者最大的区别。  



**5、模板渲染方式的不同**  

在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。

在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。

举个例子，说明React的好处：react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。  



**6、渲染过程不同**  

Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。

React在应用的状态被改变时，全部子组件都会重新渲染。通过shouldComponentUpdate这个生命周期方法可以进行控制，但Vue将此视为默认的优化。

如果应用中交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。  



**7、框架本质不同**  

Vue本质是MVVM框架，由MVC发展而来；

React是前端组件化框架，由后端组件化发展而来。  



### Vuex和Redux有什么区别？  

从表面上来说：  

store注入和使用方式有一些区别。  

在Vuex中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store来读取数据。  

在Redux中，我们每一个组件都需要显示的用connect把需要的props和dispatch连接起来。  

另外，Vuex更加灵活一些，组件中既可以dispatch action，也可以commit updates，而Redux中只能进行dispatch，不能直接调用reducer进行修改。  



从实现原理上来说 ：  

最大的区别是两点：Redux使用的是不可变数据，而Vuex的数据是可变的，因此，Redux每次都是用新state替换旧state，而Vuex是直接修改。Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter/setter来比较的，这两点的区别，也是因为React和Vue的设计理念不同。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。  

因此也会给人一种大型项目用React，小型项目用Vue的感觉。





### 自己在封装组件时需要注意哪些点？怎么样才能让组件有更好的适用性？  

* 数据的传入  
  * 数据从父组件传入时应在props中加一些限制或验证   
  * props中的数据不能直接进行修改，如果要引用可进行深拷贝 直接复制不能接触双向绑定  

*  通用组件中的事件处理应尽量放到父组件中 通用组件本身只作为中转，避免数据污染，保证更换的通用性  
*  不要过分依赖Vuex  
*  合理运用scoped编写css，在编写组件的时候，可以在style标签中添加scoped,让标签中的样式只对当前组件生效，但是一味的使用scoped，肯定会产生大量的重复代码，所以在开发的时候，应避免在组件中写样式，当全局样式写好后，再针对每个组件，通过scoped属性添加组件样式  
*  最好留一个slot，为了让通用组件能适用更多场景，应尽量留一个slot以便进行个性化配置 



### 谈谈你对前端工程化的理解？  

从四个方面考虑：  

* 模块化  
* 组件化  
* 规范化  
* 自动化  



**模块化**

模块化就是把一个大的文件，拆分成多个相互依赖的小文件，按一个个模块来划分  



**组件化**  

页面上所有的东西都可以看成组件，页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件

- 组件化≠模块化。模块化只是在文件层面上，对代码和资源的拆分；组件化是在设计层面上，对于UI的拆分
- 目前市场上的组件化的框架，主要的有Vue，React，Angular2  



**规范化**  

在项目规划初期制定的好坏对于后期的开发有一定影响。包括的规范有

- 目录结构的制定
- 编码规范
- 前后端接口规范
- 文档规范
- 组件管理
- Git分支管理
- Commit描述规范
- 定期codeReview
- 视觉图标规范  



**自动化**  

也就是简单重复的工作交给机器来做，自动化也就是有很多自动化工具代替我们来完成，例如持续集成、自动化构建、自动化部署、自动化测试等等  



### 怎样理解大前端的概念？  



个人理解大致分为两类：  

1.跨客户端，通过前端技术解决所有客户端应用。也就是说，前端团队除了开发 Web 页面以外，还需要开发 iOS 与 Android 应用，各类小程序，以及电视，车载屏幕等客户端上面的应用。所有的屏幕都归前端团队负责，目前市面的 react-native ，flutter，taro 框架就是在往这个方向发展。

2.跨服务，前端除了开发 Web 应用以外，同时还需要通过 Nodejs 开发业务相关的 Web 服务，也就是所谓的全栈。包括目前市面上的 Serverless 服务就是在朝这个方向发展。



总之一句话：**凡是能用JS实现的，终将都会用JS来做**



## Webpack  



### 说说你对webpack的理解？     

webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。  

它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。  

对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。    



### Webpack的基本功能有哪些？  

代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等
文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等
代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载
模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件
自动刷新：监听本地源代码的变化，自动构建，刷新浏览器
代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过
自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。





### 说下Webpack的构建过程    

从启动到结束会依次执行以下三大步骤：

- 初始化流程：从配置文件和 `Shell` 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数
- 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理
- 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统  



从entry里配置的module开始递归解析entry依赖的所有module
每找到一个module，就会根据配置的loader去找对应的转换规则
对module进行转换后，再解析出当前module依赖的module
这些模块会以entry为单位分组，一个entry和其所有依赖的module被分到一个组Chunk
最后webpack会把所有Chunk转换成文件输出
在整个流程中webpack会在恰当的时机执行plugin里定义的逻辑



### Webpack的一个打包原理是什么？  

将所有依赖打包成一个bundle.js，通过代码分割成单元片段按需加载  





### Webpack通常有哪些配置项？  

```javascript
module.exports = {
　　 //配置项
}
```



* entry：打包的入口文件，一个字符串或者一个对象  
* output：配置打包的结果，一个对象  
* fileName：定义输出文件名，一个字符串  
* path：定义输出文件路径，一个字符串  
* module：定义对模块的处理逻辑，一个对象  
* loaders：定义一系列的加载器，一个数组  
* resolve：影响对模块的解析，一个对象   
* extensions：自动补全识别后缀，是一个数组   
* plugins：定义插件，一个数组



### 什么是bundle,chunk,module?  

* bundle是webpack打包出来的文件  

* chunk是webpack在进行模块的依赖分析的时候，代码分割出来的代码块  

* module是开发中的单个模块



### 说说Loader和Plugin的区别？编写Loader，Plugin的思路？  

- loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中
- plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事  



两者在运行时机上的区别：

- loader 运行在打包文件之前
- plugins 在整个编译周期都起作用

在`Webpack` 运行的生命周期中会广播出许多事件，`Plugin` 可以监听这些事件，在合适的时机通过`Webpack`提供的 `API`改变输出结果

对于`loader`，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将`A.scss`或`A.less`转变为`B.css`，单纯的文件转换过程  



**编写Loader**  

在编写 `loader` 前，我们首先需要了解 `loader` 的本质

其本质为函数，函数中的 `this` 作为上下文会被 `webpack` 填充，因此我们不能将 `loader`设为一个箭头函数

函数接受一个参数，为 `webpack` 传递给 `loader` 的文件源内容

函数中 `this` 是由 `webpack` 提供的对象，能够获取当前 `loader` 所需要的各种信息

函数中有异步操作或同步操作，异步操作通过 `this.callback` 返回，返回值要求为 `string` 或者 `Buffer`

代码如下所示：

```javascript
// 导出一个函数，source为webpack传递给loader的文件源内容
module.exports = function(source) {
    const content = doSomeThing2JsString(source);
    
    // 如果 loader 配置了 options 对象，那么this.query将指向 options
    const options = this.query;
    
    // 可以用作解析其他模块路径的上下文
    console.log('this.context');
    
    /*
     * this.callback 参数：
     * error：Error | null，当 loader 出错时向外抛出一个 error
     * content：String | Buffer，经过 loader 编译后需要导出的内容
     * sourceMap：为方便调试生成的编译后内容的 source map
     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程
     */
    this.callback(null, content); // 异步
    return content; // 同步
}
```

一般在编写`loader`的过程中，保持功能单一，避免做多种功能

如`less`文件转换成 `css`文件也不是一步到位，而是 `less-loader`、`css-loader`、`style-loader`几个 `loader`的链式调用才能完成转换



**编写Plugin**  

由于`webpack`基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务

在之前也了解过，`webpack`编译会创建两个核心对象：

- compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子
- compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建

如果自己要实现`plugin`，也需要遵循一定的规范：

- 插件必须是一个函数或者是一个包含 `apply` 方法的对象，这样才能访问`compiler`实例
- 传给每个插件的 `compiler` 和 `compilation` 对象都是同一个引用，因此不建议修改
- 异步的事件需要在插件处理完任务时调用回调函数通知 `Webpack` 进入下一个流程，不然会卡住

实现`plugin`的模板如下：

```javascript
class MyPlugin {
    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象
  apply (compiler) {
    // 找到合适的事件钩子，实现自己的插件功能
    compiler.hooks.emit.tap('MyPlugin', compilation => {
        // compilation: 当前打包构建流程的上下文
        console.log(compilation);
        
        // do something...
    })
  }
}
```

在 `emit` 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容



### 说说Webpack中常见的Loader？解决了什么问题？  

`loader` 用于对模块的"源代码"进行转换，可以通过 `loader` 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性



在`webpack`内部中，任何文件都是模块，不仅仅只是`js`文件

默认情况下，在遇到`import`或者`require`加载模块的时候，`webpack`只支持对`js` 和 `json` 文件打包

像`css`、`sass`、`png`等这些类型的文件的时候，`webpack`则无能为力，这时候就需要配置对应的`loader`进行文件内容的解析  

当 `webpack` 碰到不识别的模块的时候，`webpack` 会在配置的中查找该文件解析规则

关于配置`loader`的方式有三种：

- 配置方式（推荐）：在 webpack.config.js文件中指定 loader
- 内联方式：在每个 import 语句中显式指定 loader
- CLI 方式：在 shell 命令中指定它们  



**配置方式**  

关于`loader`的配置，我们是写在`module.rules`属性中，属性介绍如下：

- `rules`是一个数组的形式，因此我们可以配置很多个`loader`
- 每一个`loader`对应一个对象的形式，对象属性`test` 为匹配的规则，一般情况为正则表达式
- 属性`use`针对匹配到文件类型，调用对应的 `loader` 进行处理

代码编写，如下形式：

```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          { loader: 'style-loader' },
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          },
          { loader: 'sass-loader' }
        ]
      }
    ]
  }
};
```



**特性**  

- loader 可以是同步的，也可以是异步的
- loader 运行在 Node.js 中，并且能够执行任何操作
- 除了常见的通过 `package.json` 的 `main` 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 `loader` 字段直接引用一个模块
- 插件(plugin)可以为 loader 带来更多特性
- loader 能够产生额外的任意文件



**常见的Loader**  

- style-loader: 将css添加到DOM的内联样式标签style里
- css-loader :允许将css文件通过require的方式引入，并返回css代码
- less-loader: 处理less
- sass-loader: 处理sass
- postcss-loader: 用postcss来处理CSS
- autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss
- file-loader: 分发文件到output目录并返回相对路径
- url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url
- html-minify-loader: 压缩HTML
- babel-loader :用babel来转换ES6文件



### 说说Webpack中常见的Plugin？解决了什么问题？  

`Plugin`（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能

是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据

`webpack`中的`plugin`也是如此，`plugin`赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 `webpack` 的不同阶段（钩子 / 生命周期），贯穿了`webpack`整个编译周期



目的在于解决`loader` 无法实现的其他事情  



**配置方式**

这里讲述文件的配置方式，一般情况，通过配置文件导出对象中`plugins`属性传入`new`实例对象。如下所示：

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装
const webpack = require('webpack'); // 访问内置的插件
module.exports = {
  ...
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin({ template: './src/index.html' }),
  ],
};
```



**特性**    

- 是一个独立的模块
- 模块对外暴露一个 js 函数
- 函数的原型 (prototype) 上定义了一个注入 compiler 对象的 apply 方法
- apply 函数中需要有通过 compiler 对象挂载的 webpack 事件钩子，钩子的回调中能拿到当前编译的 compilation 对象，如果是异步编译插件的话可以拿到回调 callback
- 完成自定义子编译流程并处理 complition 对象的内部数据
- 如果异步编译插件的话，数据处理完成后执行 callback 回调  



其本质是一个具有`apply`方法`javascript`对象

`apply` 方法会被 `webpack compiler`调用，并且在整个编译生命周期都可以访问 `compiler`对象

```javascript
const pluginName = 'ConsoleLogOnBuildWebpackPlugin';

class ConsoleLogOnBuildWebpackPlugin {
  apply(compiler) {
    compiler.hooks.run.tap(pluginName, (compilation) => {
      console.log('webpack 构建过程开始！');
    });
  }
}

module.exports = ConsoleLogOnBuildWebpackPlugin;
```



关于整个编译生命周期钩子，有如下：  

- entry-option ：初始化 option
- run
- compile： 真正开始的编译，在创建 compilation 对象之前
- compilation ：生成好了 compilation 对象
- make 从 entry 开始递归分析依赖，准备对每个模块进行 build
- after-compile： 编译 build 过程结束
- emit ：在将内存中 assets 内容写到磁盘文件夹之前
- after-emit ：在将内存中 assets 内容写到磁盘文件夹之后
- done： 完成所有的编译过程
- failed： 编译失败的时候  



**总结**  

- plugin是用来拓展webpack功能的
- plugin是一个具有 apply 属性的 JavaScript 对象
- apply 属性会被 webpack compiler 调用
- compiler 对象是 webpack 的编译器对象
- 编译器对象会有一系列hooks
- 利用hooks在不同阶段完成对被编译者的处理



**常见的Plugin**  

- **HtmlWebpackPlugin**：会在打包结束之后自动创建一个index.html, 并将打包好的JS自动引入到这个文件中。[使用说明](https://www.webpackjs.com/plugins/html-webpack-plugin/)

- **clean-webpack-plugin**：在打包之前将我们指定的文件夹清空。应用场景每次打包前将目录清空, 然后再存放新打包的内容, 避免新老混淆问题，非官方功能。[使用说明](https://github.com/johnagan/clean-webpack-plugin)
- **copy-webpack-plugin**：打包相关的文档。除了JS/CSS/图片/字体图标等需要打包以外, 可能还有一些相关的文档也需要打包（word等）。文档内容是固定不变的, 我们只需要将对应的文件拷贝到打包目录中即可。[使用说明。](https://www.webpackjs.com/plugins/copy-webpack-plugin/)
- **mini-css-extract-plugin**：是一个专门用于将打包的CSS内容提取到单独文件的插件。前面我们通过style-loader打包的CSS都是直接插入到head中的。[使用说明](https://webpack.js.org/plugins/mini-css-extract-plugin/)
- terser-webpack-plugin：压缩js代码
- optimize-css-assets-webpack-plugin：压缩css代码
- image-webpack-loader或img-loader：压缩图片。[image-webpack-loader使用说明](https://www.npmjs.com/package/image-webpack-loader)、[img-loader使用说明](https://www.npmjs.com/package/img-loader)
- postcss-sprites或webpack-spritesmith：合并图片。[postcss-sprites使用说明](https://www.npmjs.com/package/postcss-sprites)、 [webpack-spritesmith使用说明](https://www.npmjs.com/package/webpack-spritesmith)
- **webpack-merge**：用于**优化配置文件**。针对不同的环境将不同的配置写到不同的文件中。如：common文件做公共配置项文件，dev文件为开发配置，prod文件为上线配置。在dev，prod文件中配置webpack-merge，使其分别同common文件合并，并暴露给外界。
- SplitChunksPlugin：Code-Splitting实现的底层就是通过Split-Chunks-Plugin实现的，其作用就是代码分割。
- Provide-Plugin：功能同imports-loader，自动加载模块，所配置模块（jquery等）可以在全局使用。而不必在html头部引用，或在import导入模块。[使用说明](https://www.webpackjs.com/plugins/provide-plugin/)
- IgnorePlugin：用于忽略第三方包指定目录，让指定目录不被打包进去。[使用说明](https://www.webpackjs.com/plugins/ignore-plugin/)
- add-asset-html-webpack-plugin：将打包好的库引入到html界面上
- DllPlugin：生成动态库的映射关系，即dll/[name].mainfest.json文件
- DllReferencePlugin：查找动态库。把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。
- webpack-bundle-analyzer：可视化的打包优化插件。会将打包的结果以图形化界面的方式展示给我们,并且在本地开启服务器，将服务器上生成的界面自动在浏览器中展示出来。[使用说明](https://www.npmjs.com/package/webpack-bundle-analyzer)
- watch：webpack 可以监听打包文件变化，当它们修改后会重新编译打包
- webpack-dev-server：
  webpack-dev-server和watch一样可以监听文件变化，两者不要同时配置，防止冲突。
  webpack-dev-server可以将我们打包好的程序运行在一个服务器环境下
  webpack-dev-server可以解决企业开发中"开发阶段"的跨域问题
  可以监听css，js代码且能自动刷新
- **HMR(HotModuleReplacementPlugin)**：热更新插件, 会在内容发生改变的时候，时时的更新（打包）修改的内容但是不会重新刷新网站。**推荐使用**
- **babel**：将ES678高级语法转换为ES5低级语法，否则在低级版本浏览器中我们的程序无法正确执行。[使用说明](https://babeljs.io/)
- **babel-preset-env**：告诉webpack我们需要兼容哪些浏览器，然后babel就会根据我们的配置自动调整转换方案, 如果需要兼容的浏览器已经实现了, 就不转换了。
- **babel/polyfill**：没有对应关系就是指E5中根本就没有对应的语法, 例如Promise, includes等方法是ES678新增的。ES5中根本就没有对应的实现, 这个时候就需要再增加一些额外配置, 让babel自己帮我们实现对应的语法。
- babel/parser：将JS代码转换为AST抽象语法树。[使用说明](https://babeljs.io/docs/en/babel-parser)
- abel/generator：将AST抽象语法树转换为JS代码。
- babel/traverse：遍历抽象语法树。[使用说明](https://babeljs.io/docs/en/babel-traverse#docsNav)
- babel/types：创建AST抽象语法树。[使用说明](https://babeljs.io/docs/en/babel-types)
- html-withimg-loader：实现HTML中图片的打包（file-loader或者url-loader并不能将HTML中用到的图片打包到指定目录中）。[使用说明](https://www.npmjs.com/package/html-withimg-loader)



### 如何借助Webpack来优化前端性能？

通过`webpack`优化前端的手段有：

- JS代码压缩
- CSS代码压缩
- Html文件代码压缩
- 文件大小压缩
- 图片压缩
- Tree Shaking
- 代码分离
- 内联 chunk  



### 如何提高Webpack的构建速度？  

* 开启多线程打包（thread-loader）  
* 合理利用缓存（cache-loader、HardSourceWebpackPlugin、babel-loader）  
* 分包方式预编译资源模块（DLLPlugin）  
* 缩小构建目标，比如babel-loader不去解析node_modules    
* 1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree-shaking 就是只把用到的方法打入 bundle ，没用到的方法会在 uglify 阶段被擦除掉  
* 对图片资源的压缩（image-webpack-loader）  



### 与webpack类似的工具还有哪些？  

* Rollup  
* Parcel  
* Snowpack  
* Vite   
* gulp
* Webpack  
* ......  





## 后端(Node)&运维  



### 谈谈你对Node的理解  

`Node.js` 是一个开源与跨平台的 `JavaScript` 运行时环境  

可以理解为 `Node.js` 就是一个服务器端的、非阻塞式I/O的、事件驱动的`JavaScript`运行环境

### 

**非阻塞异步**  

`Nodejs`采用了非阻塞型`I/O`机制，在做`I/O`操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作

例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率  



**事件驱动**  

事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数

比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理  


![MNode](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MNode.png)




**优缺点**

优点：

- 处理高并发场景性能更佳
- 适合I/O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I/O硬盘内存读写操作



因为`Nodejs`是单线程，带来的缺点有：

- 不适合CPU密集型应用
- 只支持单核CPU，不能充分利用CPU
- 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃  



**应用场景**

借助`Nodejs`的特点和弊端，其应用场景分类如下：

- 善于`I/O`，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程
- 大量并发的I/O，应用程序内部并不需要进行非常复杂的处理
- 与 websocket 配合，开发长连接的实时交互应用程序

具体场景可以表现为如下：

- 第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序
- 第二大类：基于web、canvas等多人联网游戏
- 第三大类：基于web的多人实时聊天客户端、聊天室、图文直播
- 第四大类：单页面浏览器应用程序
- 第五大类：操作数据库、为前端和移动端提供基于`json`的API

其实，`Nodejs`能实现几乎一切的应用，只考虑适不适合使用它  



### Node都有哪些全局对象呢？  

* global  
* process  
* console  
* module  
* exports



### 谈谈你对Node中process的理解  

`process` 对象是一个全局变量，提供了有关当前 `Node.js`进程的信息并对其进行控制，作为一个全局变量

我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器

当我们启动一个`js`文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享

由于`JavaScript`是一个单线程语言，所以通过`node xxx`启动一个文件后，只有一条主线程  



**属性与方法**  

- process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息
- process.nextTick：这个在谈及 `EventLoop` 时经常为会提到
- process.pid：获取当前进程id
- process.ppid：当前进程对应的父进程
- process.cwd()：获取当前进程工作目录，
- process.platform：获取当前进程运行的操作系统平台
- process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值
- 进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听
- 三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出
- process.title 指定进程名称，有的时候需要给进程指定一个名称  



具体细节性问题[百度](https://www.baidu.com/)  



### 如何理解Node中的Buffer？    

**Buffer主要是用来处理二进制数据的**



在`Node`应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而`Buffer`就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据

在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量

如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理

这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 `RAM` 中

简单来讲，`Nodejs`不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在`Buffer`中，即在`RAM`中，直至将它们发送完毕

上面讲到了`Buffer`是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存8位二进制：`00000000`，也就是一个字节  



`Buffer`的应用场景常常与流的概念联系在一起，例如：

- I/O操作
- 加密解密
- zlib.js



### 谈谈你对Node中流的理解  

顾名思义，流就是数据流动的意思。

举个例子：

> 比如小区停水了，没想到你家用无塔供水器存了一点水，然而隔壁没有水了，想向你家借点水，直接用桶运水吧，费力气，还有可能浪费，于是可以用根管子，连接你们两家，这样就可以通过管子直接把水流到隔壁家

这就类似于`request`对象向服务器发请求要资源，在这`request`请求资源的传播方式通过流来实现  



**为什么使用流？**  

一般我们处理数据有两种模式：`buffer`模式、`stream`模式

- `buffer`模式：取完数据一次性操作
- `stream`模式：边取数据边操作

举个例子：

> 你想用手机看部电影，用buffer模式就是你把这个电影全部缓存下来，然后再看。用stream模式，就是你边缓存边看

所以从这里就可以看出`stream`模式无论是在空间和时间上都优于`buffer`模式:

- 空间上：内存只会占用当前需要处理的一块数据区域的大小, 而不是整个文件
- 时间上：因为不需要全部的数据就可以开始处理, 所以时间就相当于是节约了

还有一个好处就是可以**链式调用**

如果说写入的速度跟不上读取的速度，就有可能导致数据丢失
 所以说正常的情况应该是，**写完一段，再读取下一段，如果没有写完的话，就让读取流先暂停，等写完再继续**，（也就是你看电影的时候，缓存着看着，如果你网络不好，没缓存，就看不了，等再缓存点，再看）
 所以为了让可读流和可写流速度一致，就要用到流中必不可少的属性`pipe`了，`pipe`翻译过来意思是管道，就如上面的例子中的管子一样

**流的类型：**  

* Readable 可读流
* Writable 可写流
* Duplex 可读可写流(双工流)
* Transform 在读写过程中可以修改和变换数据的Duplex流(转换流)  



详情参考：[Node 流(stream) (可读流、可写流、双工流、转换流)](https://juejin.cn/post/6844903921295556621)





### 说下Node中的事件触发器吧(EventEmitter)  

Node中的大多数核心API类型的对象（又称触发器,Emitter）会触发命名事件来调用函数（又称监听器,Listener）

例如，`net.Server` 会在每次有新连接时触发事件，`fs.ReadStream` 会在打开文件时触发事件，`stream`会在数据可读时触发事件。

所有能触发事件的对象都是 `EventEmitter` 类的实例。 这些对象有一个 `eventEmitter.on()` 函数，用于将一个或多个函数绑定到命名事件上。

当 `EventEmitter` 对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用。 被调用的监听器返回的任何值都将会被忽略并丢弃。

例子：
 一个简单的 `EventEmitter` 实例，绑定了一个监听器。 `eventEmitter.on()` 用于注册监听器， `eventEmitter.emit()` 用于触发事件。


```javascript
const EventEmitter = require('events');

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('触发事件');
});
myEmitter.emit('event');
```



参考：[Node events(事件触发器)(EventEmitter 类)](https://juejin.cn/post/6844903921652072461)



### 通过哪些常用方法可以防止Node程序崩溃？  

（1） try-catch-finally。

（2） EventEmitter/Stream error事件处理。

（3） domain统一控制。

（4） jshint静态检查。

（5） jasmine/mocha单元测试。  





### 谈谈Node中的事件循环机制(EventLoop)  



现在Node的循环机制已经和浏览器一样了，参考JS中的EventLoop  



### 了解Node内置的模块吗？例如fs  

fs模块主要由下面几部分组成，主要用来操作文件  

（1） POSIX文件 Wrapper，对应操作系统的原生文件操作。

（2）文件流，fs. createReadStream和 fs.createWriteStrean。

（3）同步文件读写， fs.readFileSync和fs.writeFileSync。

（4）异步文件读写， fs.readFile和fs.writeFile



### Node为什么有子进程的概念，如何创建一个子进程呢？  

Node. js是异步非阻塞的，这对高并发非常有效。可是我们还有其他一些常用的需求，比如和操作系统 shell命令交互，调用可执行文件，创建子进程，进行阻塞式访问或高CPU计算等，子进程就是为满足这些需求而产生的。  

顾名思义，子进程就是把 Node. js阻塞的工作交给子进程去做  



**创建子进程**  

![MNode1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MNode1.png)



### Node进程间怎么通信？  

通信方式：

- 通过stdin/stdout传递json：最直接的方式，适用于能够拿到子进程handle的场景，适用于关联进程之间通信，无法跨机器
- Node原生IPC支持：最native（地道？）的方式，比上一种“正规”一些，具有同样的局限性
- 通过sockets：最通用的方式，有良好的跨环境能力，但存在网络的性能损耗
- 借助message queue：最强大的方式，既然要通信，场景还复杂，不妨扩展出一层消息[中间件](https://cloud.tencent.com/product/tdmq?from=10680)，漂亮地解决各种通信问题





> 通过stdin/stdout传递json

最直接的通信方式，拿到子进程的handle后，可以访问其`stdio`流，然后约定一种`message`格式开始愉快地通信：

```javascript
const { spawn } = require('child_process');child = spawn('node', ['./stdio-child.js']);
child.stdout.setEncoding('utf8');
// 父进程-发
child.stdin.write(JSON.stringify({
 type: 'handshake',
 payload: '你好吖'
}));
// 父进程-收
child.stdout.on('data', function (chunk) {
 let data = chunk.toString();
 let message = JSON.parse(data);
 console.log(`${message.type} ${message.payload}`);
});
```

子进程与之类似：

```javascript
// ./stdio-child.js
// 子进程-收
process.stdin.on('data', (chunk) => {
 let data = chunk.toString();
 let message = JSON.parse(data);
 switch (message.type) {
   case 'handshake':
     // 子进程-发
     process.stdout.write(JSON.stringify({
       type: 'message',
       payload: message.payload + ' : hoho'
     }));
     break;
   default:
     break;
 }
});
```



明显的限制是需要拿到子进程的handle，两个完全独立的进程之间无法通过这种方式来通信（比如跨应用，甚至跨机器的场景）



> 原生IPC支持

如`spawn()`及`fork()`的例子，进程之间可以借助内置的IPC机制通信

父进程：

- `process.on('message')`收
- `child.send()`发

子进程：

- `process.on('message')`收
- `process.send()`发

限制同上，同样要有一方能够拿到另一方的handle才行

> sockets

借助网络来完成进程间通信，*不仅能跨进程，还能跨机器*

node-ipc就采用这种方案，例如：

```javascript
// server
const ipc=require('../../../node-ipc');ipc.config.id = 'world';
ipc.config.retry= 1500;
ipc.config.maxConnections=1;ipc.serveNet(
   function(){
       ipc.server.on(
           'message',
           function(data,socket){
               ipc.log('got a message : ', data);
               ipc.server.emit(
                   socket,
                   'message',
                   data+' world!'
               );
           }
       );       ipc.server.on(
           'socket.disconnected',
           function(data,socket){
               console.log('DISCONNECTED\n\n',arguments);
           }
       );
   }
);
ipc.server.on(
   'error',
   function(err){
       ipc.log('Got an ERROR!',err);
   }
);
ipc.server.start();// client
const ipc=require('node-ipc');ipc.config.id = 'hello';
ipc.config.retry= 1500;ipc.connectToNet(
   'world',
   function(){
       ipc.of.world.on(
           'connect',
           function(){
               ipc.log('## connected to world ##', ipc.config.delay);
               ipc.of.world.emit(
                   'message',
                   'hello'
               );
           }
       );
       ipc.of.world.on(
           'disconnect',
           function(){
               ipc.log('disconnected from world');
           }
       );
       ipc.of.world.on(
           'message',
           function(data){
               ipc.log('got a message from world : ', data);
           }
       );
   }
);
```

当然，单机场景下通过网络来完成进程间通信有些浪费性能，但网络通信的*优势*在于跨环境的兼容性与更进一步的RPC场景



> message queue

父子进程都通过外部消息机制来通信，跨进程的能力取决于MQ支持

即进程间不直接通信，而是通过中间层（MQ），*加一个控制层*就能获得更多灵活性和优势：

- 稳定性：消息机制提供了强大的稳定性保证，比如确认送达（消息回执ACK），失败重发/防止多发等等
- 优先级控制：允许调整消息响应次序
- 离线能力：消息可以被缓存
- 事务性消息处理：把关联消息组合成事务，保证其送达顺序及完整性



比较受欢迎的有smrchy/rsmq，例如：

```javascript
// init
RedisSMQ = require("rsmq");
rsmq = new RedisSMQ( {host: "127.0.0.1", port: 6379, ns: "rsmq"} );
// create queue
rsmq.createQueue({qname:"myqueue"}, function (err, resp) {
   if (resp===1) {
     console.log("queue created")
   }
});
// send message
rsmq.sendMessage({qname:"myqueue", message:"Hello World"}, function (err, resp) {
 if (resp) {
   console.log("Message sent. ID:", resp);
 }
});
// receive message
rsmq.receiveMessage({qname:"myqueue"}, function (err, resp) {
 if (resp.id) {
   console.log("Message received.", resp)  
 }
 else {
   console.log("No messages for me...")
 }
});
```

消息的收/发/缓存/持久化依靠Redis提供的能力，在此基础上实现完整的队列机制



> Redis

基本思路与message queue类似：

Redis自带Pub/Sub机制（即发布-订阅模式），适用于简单的通信场景，比如一对一或一对多并且*不关注消息可靠性*的场景

另外，Redis有list结构，可以用作[消息队列](https://cloud.tencent.com/product/cmq?from=10680)，以此提高消息可靠性。一般做法是生产者LPUSH消息，消费者BRPOP消息。适用于要求消息可靠性的简单通信场景，但缺点是消息不具状态，且没有ACK机制，无法满足复杂的通信需求



### 你知道Node是如何处理高并发的吗？  

主要有三种方式：  

* eventproxy  
* async.queue  
* async.mapLimit   



### 说说你对中间件的理解，如何封装Node中间件？    

**中间件就相当于是秘书的作用，有事情的话，不直接汇总给老板，先汇总给秘书，然后秘书对内容进行筛选、归纳、总结，到最后再交给老板处理。**



中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的

在`NodeJS`中，中间件主要是指封装`http`请求细节处理的方法

例如在`express`、`koa`等`web`框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数

![MNodeN](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MNodeN.png)

在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作  



通常在Express和Koa框架中封装中间件  

在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据

`koa`本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得`web`应用具备良好的可拓展性和组合性

通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式  





### 介绍下Express和Koa以及区别     

Express和Koa是Node中的两大框架，他们都会有 中间件(middlewares) 的概念    



**其实Express和Koa的本质就是反复利用中间件来处理请求、数据逻辑，数据库操作的工具，来实现后端代码的书写**



**区别：**  

**中间件的执行顺序：**
其实在两种框架中，中间件的执行顺序都是**自上而下**的
然而最大的区别就是：

- `Express` 中间件链是基于回调的
- `Koa` 是基于 Promise 的  



模型：  

- `Express`为 线性模型  
- `Koa`为 洋葱型模型  



详情参考：[Express VS Koa 中间件机制分析](https://juejin.cn/post/6844903922428035085)





### 说下进程和线程的区别  

- **进程(Process)：**

进程是Windows系统中的一个基本概念，它包含着一个运行程序所需要的资源。一个正在运行的应用程序在操作系统中被视为一个进程， **进程可以包括一个或多个线程。** 线程是操作系统分配处理器时间的基本单元，在进程中可以有多个线程同时执行代码。进程之间是相对独立的，一个进程无法访问另一个进程的数据（除非利用分布式计算方式），一个进程运行的失败也不会影响其他进程的运行，Windows系统就是利用进程把工作划分为多个独立的区域的。进程可以理解为一个程序的基本边界。是应用程序的一个运行例程，是应用程序的一次动态执行过程


- **线程(Thread)：**

线程是进程中的基本执行单元，是操作系统分配CPU时间的基本单位， **一个进程可以包含若干个线程，** 在进程入口执行的第一个线程被视为这个进程的主线程。在.NET应用程序中，都是以Main()方法作为入口的，当调用此方法时系统就会自动创建一个主线程。线程主要是由CPU寄存器、调用栈和线程本地存储器组成的。CPU寄存器主要记录当前所执行线程的状态，调用栈主要用于维护线程所调用到的内存与数据，TLS主要用于存放线程的状态信息。


- **进程(Process)与线程(Thread)的区别：**
  - 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
  - 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。
  - 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
  - 对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
  - 一个程序至少有一个进程,一个进程至少有一个线程.
  - 线程的划分尺度小于进程，使得多线程程序的并发性高。
  - 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
  - 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
  - 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。





参考：[进程与线程、同步与异步、阻塞与非阻塞、并发与并行](https://juejin.cn/post/6844903848780234759) 都需要了解



### Node端如何做实时监控、如何保存日志？  

目前采用PM2做Node进程监控和管理，使用PM2的配置来保存日志输出  

可以使用[log.io](https://github.com/NarrativeScience/log.io)来做服务的实时监控  



也可以使用[log4js](https://juejin.cn/post/6953160430785151007)来做日志管理



> 追问：说下PM2的优点以及使用方式  



**优点：**  

* 后台运行(关掉cmd窗口依然运行)  
* 0 秒停机重载，维护升级时不需要停机  
* Linux (stable) & MacOSx (stable) & Windows (stable).多平台支持  
* 进程守护 (停止不稳定的进程，避免无限循环)  
* 内建负载均衡  
* 实时控制台检测  
* 提供 HTTP API等  
* 远程控制和实时的接口API ( nodejs 模块,允许和PM2进程管理器交互 )  
* 不仅仅可以启动node程序，对于一般的脚本程序同样可以


使用参考：[PM2 命令使用方法总结](https://juejin.cn/post/6889300755539312653)





### Redis了解过吗？有什么优缺点？  

redis是一个key-value存储系统，数据存储在内存中，它的优点主要如下：
  1. 支持多种数据类型

    包括set,zset,list,hash,string这五种数据类型，操作非常方便。比如，如果你在做好友系统，查看自己的好友关系，如果采用其他的key-value系统，则必须把对应的好友拼接成字符串，然后在提取好友时，再把value进行解析，而redis则相对简单，直接支持list的存储(采用双向链表或者压缩链表的存储方式)。
  2. 持久化存储

    作为一个内存数据库，最担心的，就是万一机器死机，数据会消失掉。redis使用rdb和aof做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。
  3. 丰富的特性

    pub/sub，key过期策略，事务，支持多个DB等。
   4. 性能很好

    由于是全内存操作，所以读写性能很好，可以达到10w/s的频率。公司有项目使用redis，目前的访问频率是80w/s，通过适当的部署，线上运行一切ok。

  redis的缺点主要如下：
  1. 由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
  2. 如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。
  3. 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能提供服务    



> 可能会问Redis怎么实现永久性存储(RBD、AOF)，Redis支持事务吗？请看我下面的参考链接



参考：[Redis使用教程](https://juejin.cn/post/6909672227734552583)  



### MongoDB有使用过吗？  

使用步骤：安装 --> 连接 --> new Schema --> 创建model --> 实例化model



参考：[Mongoose简单使用步骤](https://juejin.cn/post/6844903934293721096)、[MongoDB 命令集](https://juejin.cn/post/6844903927318741000)  



### Mysql命令以及使用？  

增删改查那个命令用的最多？  

答：查  



> 可能会问Mysql中的事务，拿银行转账例子即可



命令及使用参考：[MySQL常用命令及其使用](https://juejin.cn/post/6899727238392971277)  





### MongoDB与Mysql有什么区别？  

关系型数据库-MySQL

1. 在不同的引擎上有不同的存储方式。  
2. 查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高。  
3. 开源数据库的份额在不断增加，mysql的份额页在持续增长。  
4. 缺点就是在海量数据处理的时候效率会显著变慢。



非关系型数据库-MongoDB
非关系型数据库(nosql ),属于文档型数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。这些数据具备自述性，呈现分层的树状数据结构。数据结构由键值(key=>value)对组成。

1. 存储方式：虚拟内存+持久化。  
2. 查询语句：是独特的MongoDB的查询方式。  
3. 适合场景：事件的记录，内容管理或者博客平台等等。  
4. 架构特点：可以通过副本集，以及分片来实现高可用。  
5. 数据处理：数据是存储在硬盘上的，只不过需要经常读取的数据会被加载到内存中，将数据存储在物理内存中，从而达到高速读写。  
6. 成熟度与广泛度：新兴数据库，成熟度较低，Nosql数据库中最为接近关系型数据库，比较完善的DB之一，适用人群不断在增长。 



**MongoDB优势与劣势**  

优势：

1. 在适量级的内存的MongoDB的性能是非常迅速的，它将热数据存储在物理内存中，使得热数据的读写变得十分快。  
2. MongoDB的高可用和集群架构拥有十分高的扩展性。  
3. 在副本集中，当主库遇到问题，无法继续提供服务的时候，副本集将选举一个新的主库继续提供服务。  
4. MongoDB的Bson和JSon格式的数据十分适合文档格式的存储与查询。



劣势：

1. 不支持事务操作。MongoDB本身没有自带事务机制，若需要在MongoDB中实现事务机制，需通过一个额外的表，从逻辑上自行实现事务。  
2.  应用经验少，由于NoSQL兴起时间短，应用经验相比关系型数据库较少。  
3. MongoDB占用空间过大。



### 什么是死锁？  

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程    

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

* 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。  


* 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。





### Redis与Mysql的事务有什么不同？  



记住一点即可：**Redis事务不支持Rollback**  



事实上Redis命令在事务执行时可能会失败，但仍会继续执行剩余命令而不是Rollback（事务回滚）。如果你使用过关系数据库，这种情况可能会让你感到很奇怪。然而针对这种情况具备很好的解释：

Redis命令可能会执行失败，仅仅是由于错误的语法被调用（命令排队时检测不出来的错误），或者使用错误的数据类 型操作某个Key：

这意味着，实际上失败的命令都是编程错误造成的，都是开发中能够被检测出来的，生产环境中不应该存在。

由于不必支持Rollback,Redis内部简洁并且更加高效。



所以说当Mysql开启事务并且中间某一步执行失败，那么数据会回到最原始的状态(其实在执行过程中并没有修改数据)，而Redis开启事务并且中间某一步执行失败，那么之前执行的语句所产生和修改的数据是不可回滚的。  





### Nginx有什么优点以及怎么使用？  

Nginx是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器

优点：

- 正向代理
- 反向代理
- 负载均衡
- 动静分离

> 1. **更快**：一方面，在正常情况下，单次请求会得到更快的响应；另一方面，在高峰期（如有数以万计的并发请求），Nginx可以比其他Web服务器更快地响应请求。
> 2. **高扩展性（跨平台）**：可以开发符合自己业务特性的定制模块。
> 3. **高可靠性**：用于反向代理，宕机的概率微乎其微。
> 4. **低内存消耗**
> 5. **单机支持10万以上的并发连接**：理论上，Nginx支持的并发连接上限取决于内存，10万远未封顶。
> 6. **热部署**：master管理进程与worker工作进程的分离设计，使得Nginx能够提供热部署功能，即可以在7×24小时不间断服务的前提下，升级Nginx的可执行文件。当然，它也支持不停止服务就更新配置项、更换日志文件等功能。
> 7. **最自由的BSD许可协议**：BSD许可协议不只是允许用户免费使用Nginx，它还允许用户在自己的项目中直接使用或修改Nginx源码，然后发布。





使用参考：[Nginx使用及配置](https://juejin.cn/post/6898200676611358733)





### Docker有了解过吗？  

Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。

Docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。Docker就是集装箱。

1. 不同的应用程序可能会有不同的应用环境，比如.net开发的网站和php开发的网站依赖的软件就不一样，如果把他们依赖的软件都安装在一个服务器上就要调试很久，而且很麻烦，还会造成一些冲突。比如IIS和Apache访问端口冲突。这个时候你就要隔离.net开发的网站和php开发的网站。常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小，小就意味着省钱了。

2. 你开发软件的时候用的是Ubuntu，但是运维管理的都是centos，运维在把你的软件从开发环境转移到生产环境的时候就会遇到一些Ubuntu转centos的问题，比如：有个特殊版本的数据库，只有Ubuntu支持，centos不支持，在转移的过程当中运维就得想办法解决这样的问题。这时候要是有docker你就可以把开发环境直接封装转移给运维，运维直接部署你给他的docker就可以了。而且部署速度快。

3. 在服务器负载方面，如果你单独开一个虚拟机，那么虚拟机会占用空闲内存的，docker部署的话，这些内存就会利用起来。

总之**Docker就是集装箱原理**。  



Docker的使用参考：[Docker总结(命令、镜像、容器、数据卷、DockerFile、网络、Compose)](https://juejin.cn/post/6896027012410900488)  



### 写过Shell脚本吗？  

下去看下文档就行，一般不会问  



参考：[Shell脚本中常用命令](https://www.zutuanxue.com/home/4/6_8)  



贴一下我自己写的一个批量修改文件名称的一个脚本  

```shell
#! /bin/bash

#Author: FanJunyang
#Description: modify file name
read -p "输入要修改的文件夹路径(不填的话默认为当前文件夹下): " BASEURL
if [ -z "$BASEURL" ];then
        BASEURL="./"
fi
if [ -n "$BASEURL" ] && [ "`echo ${BASEURL: -1}`" != "/" ];then
        BASEURL="$BASEURL/"
fi

read -p "输入要批量修改的文件后缀,例如(.txt): " FILETYPE
fileList=(`ls $BASEURL | egrep "$FILETYPE$"`)
read -p "输入修改后的文件名称(默认以_n结尾): " NEWFILE

for (( i=1;i<=${#fileList[*]};i++ ))
do
        mv $BASEURL${fileList[i-1]} $BASEURL$NEWFILE"_"$i$FILETYPE
done
```





## 项目相关    



### Git   

> 在面试中也可能问到Git的常用命令等...看我下面的参考链接  



列举几个重点问题：  

* **Git中`reset`和`revert`有什么区别？(重点)**  
* 你们是怎么协同开发的(主要是冲突问题)？  
* 遇到过代码丢失问题吗？



参考，一篇足矣：[高频 Git 命令集](https://juejin.cn/post/6844904015654813710)  



### 适配方案  

通常使用REM+Flex布局实现适配    

```javascript
<script>
	;(function () {
		// 设计稿宽度 px
		var designWidth = 375
		// rem 基准字号 px
		var baseFontSize = 100
		// 最大适配宽度 px
		var maxAdaptWidth = 1024

		var adaptDevice = function () {
			var deviceWidth = document.documentElement.clientWidth
			deviceWidth = deviceWidth > maxAdaptWidth ? maxAdaptWidth : deviceWidth
			var scale = deviceWidth / designWidth
			var adaptRootFontSize = baseFontSize * scale
			document.querySelector('html').style.fontSize = adaptRootFontSize + 'px'
		}

		var timer = 0
		window.addEventListener('resize', function () {
			if (timer) {
				clearTimeout(timer)
				timer = 0
			}

			timer = setTimeout(function () {
				adaptDevice()
			}, 0)
		})

		setTimeout(adaptDevice, 0)
	}())
</script>
```



### 如果后端返回数据量比较大怎么办？  

从后端的角度：

* 尽量预处理并规整返回的数据：给到合理的数据格式以及需要用作展示的数据，尽量减轻前端的数据处理逻辑。 

从前端的角度：

* 数据传输大，意味着会有较长的网络传输时间，那么最好的方式就是要进行数据缓存。
* 从另外一个角度，可以使用 NodeJS 中间层的方式，不经过浏览器先行请求接口数据并将数据预处理，前端通过调用中间层暴露的接口来调用，浏览器获得的即为中间层处理后的数据，前端可以减轻大量的逻辑处理，拿到的数据可以直接使用，也可以提高页面渲染效率。  
* 当然，渲染是浏览器的事，但是最好也做到按需加载提高性能。      
* 用虚拟列表  



### 记录  

项目权限问题  

封装过axios吗？  

断点续传  

首页白屏怎么解决  

日志怎么存储

怎么管理状态  

如果页面中有输入框，刷新后不让输入框数据丢失，怎么做？

来回切换tabbar时，不能重新请求数据  

把数据缓存到内存中，避免再次去请求接口    

有的页面需要缓存，有的不需要怎么办？  

在一个页面中滑倒中间位置，如果切换页面，再切换回去，应该还是处于中间位置怎么办？  

对于一个app来说，有的页面需要登录后才能看到，有的则不需要怎么办？  

怎么验证登录？   

```txt
1.验证是否登录过，如果登录过，服务器会返回客户端一个token  
2.客户端把token保存在localStorage中，后面客户再去请求服务器，会在请求拦截那里带上token  
3.如果调用/validata接口时，如果你带着token去访问这个接口，就返回你已登录，如果你没有带上token，就给你返回未登录。 
```



如果给你个项目，你会选择什么框架(Vue或React)?   

给个1000条数据的列表，用JS动态渲染节点  

怎么自定义一个table组件（动态添加表头等）

接口在极短时间内重复请求怎么解决？ 







## 算法题&手写原理&做做题  



### 实现Promise.all  

```javascript
function promiseAll(iterable) {
    const array = [...iterable]
    const result = []
    return new Promise((reslove, reject) => {
        for(let i = 0; i < array.length; i++) {
            Promise.resolve(array[i]).then(res => {
                result.push(res)
                result.length === array.length && reslove(result)
            }).catch(reason => {
                reject(reason)
            })
        }
    })
}
```





### 实现call、apply、bind  

```javascript
// call  
Function.prototype.myCall = function(context = window, ...args) {
    context = context || window; // 参数默认值并不会排除null，所以重新赋值
    context.fn = this; // this是调用call的函数
    const result = context.fn(...args);
    delete context.fn; // 执行后删除新增属性
    return result;
}

function fn1(m, n) {
    console.log(this.name)  // FAN
    console.log(m + n)  // 3
}
// 接受的是一个参数列表;方法立即执行
fn1.myCall({ name: 'FAN' }, 1, 2)


// apply

Function.prototype.myApply = function(context = window, args = []) {
    context = context || window; // 参数默认值并不会排除null，所以重新赋值
    context.fn = this; // this是调用call的函数
    const result = context.fn(...args);
    delete context.fn; // 执行后删除新增属性
    return result;
}

function fn2(m, n) {
    console.log(this.name)  // FAN
    console.log(m + n)  // 3
}
// 接受的是一个参数列表;方法立即执行
fn2.myApply({ name: 'FAN' }, [1, 2])


// bind  
Function.prototype.myBind = function(context, ...args) {
    const _this = this;
    return function Bind(...newArgs) {
        // 考虑是否此函数被继承
        if (this instanceof Bind) {
            return _this.myApply(this, [...args, ...newArgs])
        }
        return _this.myApply(context, [...args, ...newArgs])
    }
}

function fn3(m, n) {
    console.log(this.name)  // FAN
    console.log(m + n)  // 3
}
// 接受的是一个参数列表;方法立即执行
fn3.myBind({ name: 'FAN' }, 1, 2)()
```



### 手写forEach、Map  

```javascript
Array.prototype.myMap = function(fn) {
	// this指的是原数组，调用这个方法的数组
    const res = [];
    for(let i = 0; i < this.length; i++) {
      res.push(fn(this[i], i, this));
    }
    return res;
}

console.log(['a', 'b', 'c'].myMap((item) => {
    return item + 1
}));
```



### 手写JSONP  

```javascript
function jsonp(url, params = {}, callback) {
    // 处理json对象，拼接url
    params.callback = callback
    const paramsArr = []
    for (const key in params) {
        paramsArr.push(`${key}=${params[key]}`)
    }
    let script = document.createElement('script')
    script.src = `${url}?${paramsArr.join('&')}`
    document.body.appendChild(script)
    return new Promise((reslove, reject) => {
        window[callback] = res => {
            try {
                reslove(res)
            } catch(e) {
                reject(e)
            } finally {
                // 移除script
                script.parentNode.removeChild(script)
            }
        }
    })
}
```



### 手写reduce  

```javascript
Array.prototype.myReduce = function(fn) {
    const arr = this
    let total = arr[0]
    for(let i=1; i<arr.length; i++) {
        total = fn(total, arr[i], i, arr)
    }
    return total
}
```



### 手写Promise   

优化版本，（如果看不懂，掌握下面简化版本就行，足够用了）

```javascript
// 手写Promise
class YX {
    // 定义静态属性(状态)
    static PENDING = 'pending'
    static FULFILLED = 'fulfilled'
    static REJECTED = 'rejected'
    // 初始化 executor(执行者，相当于callback)
    constructor(executor) {
        // 初始化
        this.status = YX.PENDING
        // 存放成功或者失败的值
        this.value = null
        // 存放异步任务
        this.callbacks = []
        // 处理异常状态
        try {
            // 执行((resolve, reject) => {})
            executor(this.resolve.bind(this), this.reject.bind(this))
        } catch (error) {
            // 发生错误就是拒绝态
            this.reject(error)
        }
    }
    // 成功态
    resolve(value) {
        // 如果状态已经改变，则不能再次改变状态
        if(this.status === YX.PENDING) {
            this.status = YX.FULFILLED
            this.value = value
            // 变为异步任务
            setTimeout(() => {
                // 处理等待态成功的异步任务
                this.callbacks.map(callback => {
                    callback.onFulfilled(value)
                })
            })
        }
    }
    // 拒绝态
    reject(reason) {
        // 如果状态已经改变，则不能再次改变状态
        if(this.status === YX.PENDING) {
            this.status = YX.REJECTED
            this.value = reason
            // 变为异步任务
            setTimeout(() => {
                // 处理等待态拒绝的异步任务
                this.callbacks.map(callback => {
                    callback.onRejected(reason)
                })
            })
        }
    }
    // then
    then(onFulfilled, onRejected) {
        // 如果不想要成功态，只想要失败态，那么传个null也行，
        // 例如：new Promise((resolve, reject) => {}).then(null, reject => {})
        // 所以自己封装个函数给他返回
        if (typeof onFulfilled !== 'function') {
            onFulfilled = () => {
                // then穿透处理，例如:new Promise((reslove) => {reslove('nh')}).then().then(v => console.log(v))
                return this.value
            }
        }
        if (typeof onRejected !== 'function') {
            // then穿透处理
            onRejected = () => this.value
        }
        // 支持链式调用then(递归)
        const promise = new YX((resolve, reject) => {
            // 如果状态为成功态，则执行传递的函数，并把值带过去
            if (this.status === YX.FULFILLED) {
                // 放到异步队列里
                setTimeout(() => {
                    this.parse(promise, onFulfilled(this.value), resolve, reject)
                })
            }
            // 如果状态为失败态，则执行传递的函数，并把值带过去
            if (this.status === YX.REJECTED) {
                // 放到异步队列里
                setTimeout(() => {
                    this.parse(promise, onRejected(this.value), resolve, reject)
                })
            }
            // 如果是等待态，则把等会要处理的函数放到callbacks中，等到时间了，自动处理
            // 例如：
            // new Promise((reslove, reject) => {
            //     setTimeout(() => {
            //         reslove('解决')
            //     }, 1000)
            // }).then(v => {
            //     console.log(v)
            // })
            if (this.status === YX.PENDING) {
                this.callbacks.push({
                    onFulfilled: value => {
                        this.parse(promise, onFulfilled(value), resolve, reject)
                    },
                    onRejected: reason => {
                        this.parse(promise, onRejected(reason), resolve, reject)
                    },
                })
            }
        })
        return promise
    }
    // 代码优化
    parse(promise, result, resolve, reject) {
        // 不允许循环调用
        if (promise === result) {
            throw new TypeError('Chaining cycle detected')
        }
        try {
            if (result instanceof YX) {
                // 如果返回的值是个Promise，则进行处理(再次调用then即可)
                result.then(resolve, reject)
            } else {
                // 如果返回的是普通值，直接返回
                resolve(result)
            }
        } catch (error) {
            reject(error)
        }
    }
    // 静态方法resolve
    static resolve(value) {
        return new YX((resolve, reject) => {
            if (value instanceof YX) {
                value.then(resolve, reject)
            } else {
                resolve(value)
            }
        })
    }
    // 静态方法reject
    static reject(value) {
        return new YX((resolve, reject) => {
            reject(value)
        })
    }
    // 静态方法all
    static all(promises) {
        return new YX((resolve, reject) => {
            const values = []
            promises.forEach(promise => {
                promise.then(value => {
                    values.push(value)
                    // 如果都成功，则改变状态
                    if (values.length === promises.length) {
                        resolve(values)
                    }
                }, reason => {
                    // 如果有一个失败，则走reject
                    reject(reason)
                })
            })
        })
    }
    // 静态方法race
    static race(promises) {
        return new YX((resolve, reject) => {
            promises.map(promise => {
                promise.then(value => {
                    // 如果有一个成功，则直接改变状态即可
                    resolve(value)
                }, reason => {
                    reject(reason)
                })
            })
        })
    }
}
```



简化版本  

```javascript
class MyPromise{
    static PENDING = 'pending'
    static FULFILLED = 'fulfilled'
    static REJECTED = 'rejected'
    constructor(exector) {
        this.value = null
        this.status = MyPromise.PENDING
        this.callbacks = []
        try {
            exector(this.reslove.bind(this), this.reject.bind(this))
        } catch(err) {
            this.reject(err)
        }
    }
    reslove(value) {
        if (this.status === MyPromise.PENDING) {
            this.value = value
            this.status = MyPromise.FULFILLED
            this.callbacks.forEach(callback => {
                callback.onFulfilled(value)
            })
        }
    }
    reject(reason) {
        if (this.status === MyPromise.PENDING) {
            this.value = reason
            this.status = MyPromise.REJECTED
            this.callbacks.forEach(callback => {
                callback.onRejected(reason)
            })
        }
    }
    then(onFulfilled, onRejected) {
        if (typeof onFulfilled !== 'function') {
            onFulfilled = () => this.value
        }
        if (typeof onRejected !== 'function') {
            onRejected = () => this.value
        }
        return new MyPromise((reslove, reject) => {
            if (this.status === MyPromise.PENDING) {
                this.callbacks.push({
                    onFulfilled: value => {
                        const res = onFulfilled(value)
                        if (res instanceof MyPromise) {
                            res.then(reslove, reject)
                        } else {
                            reslove(res)
                        }
                    },
                    onRejected: reason => {
                        const res = onRejected(reason)
                        if (res instanceof MyPromise) {
                            res.then(reslove, reject)
                        } else {
                            reject(res)
                        }
                    }
                })
            }
            if (this.status === MyPromise.FULFILLED) {
                const res = onFulfilled(this.value)
                if (res instanceof MyPromise) {
                    res.then(reslove, reject)
                } else {
                    reslove(res)
                }
            }
            if (this.status === MyPromise.REJECTED) {
                const res = onRejected(this.value)
                if (res instanceof MyPromise) {
                    res.then(reslove, reject)
                } else {
                    reject(res)
                }
            }
        })
    }
    static all(promises) {
        return new MyPromise((reslove, reject) => {
            const res = []
            promises.forEach(promise => {
                promise.then(value => {
                    res.push(value)
                    promises.length === res.length && reslove(res)
                }, reason => {
                    reject(reason)
                })
            })
        })
    }
    static race(promises){
        return new MyPromise((reslove, reject) => {
            promises.forEach(promise => {
                promise.then(value => {
                    reslove(value)
                }, reason => {
                    reject(reason)
                })
            })
        })
    }
    static reslove(value) {
        return new MyPromise((reslove, reject) => {
            if (value instanceof MyPromise) {
                value.then(reslove, reject)
            } else {
                reslove(value)
            }
        })
    }
    static reject(reason) {
        return new MyPromise((reslove, reject) => {
            if (reason instanceof MyPromise) {
                reason.then(reslove, reject)
            } else {
                reject(reason)
            }
        })
    }
}
```



### 二分查找  

```javascript
// 二分查找（递归）
function searchTwo (target, array, start, end) {
    if (start > end) return -1
    start = start || 0
    end = end || array.length - 1
    let mid = parseInt((end - start) / 2 + start)
    if (target == array[mid]) {
        return mid
    }
    if (target > array[mid]) {
        return searchTwo(target, array, mid + 1, end)
    }
    if (target < array[mid]) {
        return searchTwo(target, array, start, mid - 1)
    }
}

// console.log(searchTwo(5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 18, 58, 42]));
```



### 数组最大子序和  

```javascript
// 最大子序和
function maxAddArray (array) {
    let max = array[0]
    let m = 0
    for (let i = 0; i < array.length; i++) {
        m = Math.max( m + array[i], array[i])
        max = Math.max(max, m)
    }
    return max
}

// console.log(maxAddArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));


// max -2  (-2, -2) = -2   (-2, 1) = 1     (1, -2) = 1     (1, 4) = 4  (4, 3) = 4  (4, 5) = 5  (5, 6) = 6  (6, 1) = 6

// m   0   (-2, -2) = -2   (-1, 1) = 1     (-2, -3) = -2   (2, 4) = 4  (3, -1) = 3 (5, 2) = 5  (6, 1) = 6  (1, -5) = 1
```



### 数组扁平化  

```javascript
// 将二维数组转化为一维数组
function twoOneArray (array) {
    return array.reduce((p, i) => [...p, ...i], [])
}

// console.log(twoOneArray([[0, 1], [2, 3], [4, 5]]))

/***************************************************************************** */

// 将多维数组转化为一维
function someToOne (array) {
    return array.reduce((p, i) => p.concat(Array.isArray(i) ? someToOne(i) : i), [])
}

// console.log(someToOne([[0, 1], [2, 3], [4,[5,6,7]]]))

/***************************************************************************** */


// 简洁方式  
console.log([[0, 1], [2, 3], [4,[5,6,7]]].flat(Infinity))
// 利用toString方法(注意数组中数据全都为字符串才可以，否则还需要处理)  
console.log([['0', '1'], ['2', '3'], ['4',['5','6','7']]].toString().split(','))
```



### 手写new原理  

```javascript
function B(name, age) {
    this.name = name
    this.age = age
}

// 手写new原理
function create() {
    // 创建空对象
    let obj = new Object()
    // 获取构造函数
    let Constructor = [].shift.call(arguments)
    // 链接到原型
    obj.__proto__ = Constructor.prototype
    // 绑定this
    let result = Constructor.apply(obj, arguments)
    // 返回新对象,(如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象)
    return typeof result === 'object' ? result : obj
}

let b1 = new B('fan', 18)
let b2 = create(B, 'jun', 20)
```



### 函数柯里化  

```javascript
// 函数柯里化
function toCurry(fn, ...args) {

    if(args.length >= fn.length) {
        return fn.apply(null, args);
    }

    return (...args2) => toCurry(fn, ...args, ...args2);
}

const add = toCurry(function(a, b, c) {
    return a + b + c;
});

// console.log(add(1, 2, 3))
// console.log(add(1)(2)(3))
// console.log(add(1, 2)(3))
// console.log(add(1)(2, 3))
```



### 深拷贝  

```javascript
// 深拷贝
function deepClone(source) {
    // 判断复制的目标是数组还是对象
    const target = source.constructor === Array ? [] : {}
    // 遍历目标
    for (const key in source) {
        if (source[key] && typeof source[key] === 'object') {
            // 对象 || 数组
            target[key] = source[key].constructor === Array ? [] : {}
            target[key] = deepClone(source[key])
        } else {
            // 不是对象或者数组，直接赋值
            target[key] = source[key]
        }
    }
    return target
}
```



### 求数组交集、并集、差集  

```javascript
// 交集
function intersection1(arr1, arr2) {
    return [...new Set(arr1)].filter(i => {
        return new Set(arr2).has(i)
    })
}

function intersection2(arr1, arr2) {
    return arr1.reduce((i, v) => {
        if (arr2.includes(v)) i = [...i, v]
        return i
    }, [])
}

// 并集
function union1(arr1, arr2) {
    return [...new Set([...arr1, ...arr2])]
}

function union2(arr1, arr2) {
    return [...arr1, ...arr2].reduce((i, v) => {
        if ((arr1.includes(v) || arr2.includes(v)) && !i.includes(v)) i = [...i, v]
        return i
    }, [])
}

// 差集
function difference1(arr1, arr2) {
    return [...[...new Set(arr1)].filter(i => !new Set(arr2).has(i)),
            ...[...new Set(arr2)].filter(i => !new Set(arr1).has(i))]
}

function difference2(arr1, arr2) {
    return [...arr1, ...arr2].reduce((i, v) => {
        if (!arr1.includes(v) || !arr2.includes(v)) i = [...i, v]
        return i
    }, [])
}

// console.log(intersection1([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(intersection2([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(union1([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(union2([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(difference1([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(difference2([1, 2, 3, 4], [3, 4, 5, 6]))
```



### 防抖节流  

```javascript
// 防抖节流

// 防抖(在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时)
function debounce(fn, delay) {
    let t = delay || 500
    let timer
    return function() {
        clearTimeout(timer)
        timer = setTimeout(() => {
            // 改变this指向并传递参数
            fn.apply(this, arguments)
        }, t)
    }
}

/**

HTML代码示例

<body>
    <div id="container"></div>
</body>
<script>
    let count = 1
    let container = document.getElementById('container')
    function test(e) {
        // 如果debounce不加参数arguments，这里会打印undefined
        console.log(e)
        // 如果debounce不改变this指向，这里会打印window,而不是DOM节点
        console.log(this)
        container.innerHTML = count++;
    }
    function debounce(fn, delay) {
        let t = delay || 500
        let timer
        return function() {
            clearTimeout(timer)
            timer = setTimeout(() => {
                fn.apply(this, arguments)
            }, t)
        }
    }
    container.onmousemove = debounce(test, 1000)
</script>

 */

// 节流(规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效)
function throttle(fn, delay) {
    let t = delay || 500
    let timer
    return function() {
        if (!timer) {
            timer = setTimeout(() => {
                // 为了方便下次执行定时器
                timer = null
                fn.apply(this, arguments)
            }, t)
        }
    }
}

/**

HTML代码示例

<body>
    <div id="container"></div>
</body>
<script>
    let count = 1
    let container = document.getElementById('container')
    function test() {
        container.innerHTML = count++;
    }
    function throttle(fn, delay) {
        let t = delay || 500
        let timer
        return function() {
            if (!timer) {
                timer = setTimeout(() => {
                    // 为了方便下次执行定时器
                    timer = null
                    fn.apply(this, arguments)
                }, t)
            }
        }
    }
    container.onmousemove = throttle(test, 2000)
</script>

 */
```





### 统计字符串或者数组中字符出现的次数  

```javascript
// 统计字符串或者数组中字符出现的次数
function strArrNum(params) {
    let arr = []
    params instanceof Array
        ? arr = params
        : arr = params.split('')
    return arr.reduce((i ,v) => {
        if (i[v]) {
            i[v] += 1
        } else {
            i[v] = 1
        }
        return i
    }, {})
}

// console.log(strArrNum('aiusgdkhhcasdasdasdjhbcdshb'))

// 扩展，取出现最多的字符
const finalRes = strArrNum('aiusgdkhhcasdasdasdjhbcdshb')

let finalArr = []
for (const key in finalRes) {
    if (finalRes[key] === Math.max(...Object.values(finalRes))) {
        finalArr.push(key)
    }
}

// console.log(finalArr)
```



### 阶乘  

```javascript
// 阶乘
function factorial (num) {
    if (num < 0) return -1
    return num === 1 ? 1 : num * factorial (--num)
}

// console.log(factorial (5))
```



### 驼峰与下划线之间互转  

```javascript
// 下划线转驼峰
function toHump(str) {
    // _代表匹配的整体字符串,l表示匹配正则的()分组
    return str.replace(/_(\w)/g, (_, l) => {
        return l.toUpperCase();
    });
}

// console.log(toHump('hello_word'))

// 驼峰转下划线
function toLine(str) {
    return str.replace(/([A-Z])/g,"_$1").toLowerCase();
}

// console.log(toLine('helloWord'))
```



### 数组排序（冒泡、选择、快排等）  

```javascript
// 冒泡排序(两两比较)
function bubbleAsSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j + 1]
                arr[j + 1] = arr[j]
                arr[j] = temp
            }
        }
    }
    return arr
}

// console.log(bubbleAsSort([2,9,5,8,6,4,3,7]))

// 选择排序(遍历自身以后的元素，最小的元素跟自己调换位置)
function selectAsSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - 1; j++) {
            if (arr[j] < arr[i]) {
                [arr[i], arr[j]] = [arr[j], arr[i]]
            }
        }
    }
    return arr
}

// console.log(selectAsSort([2,9,5,8,5,6,4,3,7]))
```



### 斐波那契数列   

```javascript
// 斐波那契数列
// 斐波那契数列（Fibonacci sequence），又称黄金分割数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）

// 采用递归（存在重复调用缺陷）
function fib(n) {
    if (n < 2) return 1
    return fib(n - 2) + fib(n - 1)
}

// console.log(fib(6))

// 递归优化 空间复杂度O(n),将函数执行结果用变量缓存起来的方法。当函数进行计算之前，先看缓存对象中是否有次计算结果，如果有，就直接从缓存对象中获取结果；如果没有，就进行计算，并将结果保存到缓存对象中
function fibonacciOn(n) {
    // 用一个数组来存储斐波那契数字
    const cache = [0, 1]
    for (let i = 2; i <= n; i++) {
        cache[i] = cache[i - 1] + cache[i - 2]
    }
    return cache[n]
}

// console.log(fibonacciOn(6))

// 递归优化 空间复杂度O(1)
function fibonacciO1(n, current = 0, next = 1) {
    for(let i = 0; i < n; i++) {
        [current, next] = [next, current + next]
    }
    return current
}

// console.log(fibonacciO1(6))

// 尾递归(只在严格模式下才能使用)
'use strict'
function fibTail(n, current = 0, next = 1) {
    if(n == 0) return 0;
    if(n == 1) return next
    return fibTail(n - 1, next, current + next)
}

// console.log(fibTail(6))
```



### 分解质因数  

```javascript
function commit(num) {
    let str = ''
    for(let i=2; i<=num; i++) {
        if (num % i === 0) {
            num = num / i
            str += i
            i = 1
        }
    }
    return str
}

// console.log(commit(180))
```





### 求最小公倍数和最大公约数    

示例：    

求最大公约数方法：辗转相除法
始终用较大数除以较小数，然后用余数代替较大数
最终结果余数为0时，整数就是最大公约数  

举例：225 125求最大公约数
225 125(225除以125余数100)
125 100(125除以100余数25)
100 25 (100除以25余数0)
所以最大公约数为25

求最小公倍数方法：最小公倍数等于两数之积除以最大公约数
225 125求最小公倍
225\*125/25 = 1125
所以最小公倍结果：1125

```javascript
function minMaxNum(a, b) {
    let min = Math.min(a, b);
    let max = Math.max(a, b);
    let loop = 1
    while(loop !== 0) {
        loop = max % min
        max = min
        min = loop
    }
    console.log(`最大公约数：${max}`);
    console.log(`最小公倍数：${Math.max(a, b) * Math.min(a, b) / max}`);
}

minMaxNum(52, 24)
```



### 画三角  

```javascript
function triangle(num) {
    return [...Array(num)].map((_, i) => `${' '.repeat(num - i)}${'#'.repeat(1 + 2 * i)}\n`).join('')
}

console.log(triangle(10));
```



### 杨辉三角  

```javascript
function generate(numRows) {
    return Array(Math.max(2, numRows) - 2).fill(0).reduce(dp => dp.concat([[1, ...dp[dp.length - 1].reduce((p, v, i, arr) => (i < arr.length - 1 && p.push(v + arr[i + 1]), p) , []) ,1]]), [[1], [1,1]]).slice(0, numRows)
};

console.log(generate(8));
```



### 字符串出现的不重复最长长度  

```javascript
function longStrLength(str) {
    let newStr = ''
    let len = 0
    for (const i of str) {
        let index = newStr.indexOf(i)
        if (index === -1) {
            newStr += i
        } else {
            newStr = newStr.slice(index + 1) + i
        }
        len = len > newStr.length ? len : newStr.length
    }
    return len
}

console.log(longStrLength('asdfass'));
```





### 实现a.add(1).add(2).add(3)   

```javascript
class SUM {
    constructor(n) {
        this.num = n
    }
    add(m) {
        this.num += m
        return new SUM(this.num)
    }
}

console.log(new SUM(1).add(2).add(3));
```



### 两个有序数组归并排序  

```javascript
function test(arr1, arr2) {
    let newArr = []
    let len = Math.max(arr1.length, arr2.length)
    while(len > 0) {
        if (arr1.length !== 0 && arr2.length !== 0) {
            if (arr1[0] > arr2[0]) {
                newArr.push(arr2.shift())
            } else if (arr1[0] < arr2[0]) {
                newArr.push(arr1.shift())
            } else {
                newArr.push(arr1.shift())
                newArr.push(arr2.shift())
            }
        } else if (arr1.length === 0) {
            newArr = [...newArr, ...arr2]
            arr2 = []
        } else {
            newArr = [...newArr, ...arr1]
            arr1 = []
        }
        len = Math.max(arr1.length, arr2.length)
    }
    return newArr
}

console.log(test([1,2,3,4], [3,4,5,6]));
```





### 随机打乱数组顺序  

打乱数组`[1, 2, 3,...1000]`  

```javascript
// 这种并不是真正意义上的乱序
console.log([...Array(100).keys()].sort(() => {
    return Math.random() - .5
}));
```



```javascript
// 洗牌算法
Array.prototype.shuffle = function() {
    let array = this;
    let len = array.length;
    for (let i = len - 1; i > 0; i--) {
      let j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array
}

console.log([...Array(100).keys()].shuffle());
```





### 扁平数据结构转tree  

```javascript
function flatConvArr(arr) {
    let [_, tree] = arr.reduce((temp, v) => {
        let node = {...v, children: []}
        let parent_node = temp[v.pid]
        if (parent_node) {
            parent_node.children.push(node)
        }
        temp[v.id] = node
        return temp
    }, [])

    return tree
}

console.log(flatConvArr([
    {id: 1, name: '部门1', pid: 0},
    {id: 2, name: '部门2', pid: 1},
    {id: 3, name: '部门3', pid: 1},
    {id: 4, name: '部门4', pid: 3},
    {id: 5, name: '部门5', pid: 4},
]))
```



### 红色区域宽度  

```css
div {
      width: 100px;
      height: 100px;
      border: 1px solid #000;
      padding: 20px;
      margin: 20px;
      background: red;
      background-clip: content-box;
}
```



### 不用循环写个0~99的数组  

```javascript
[...Array(100).keys()]
```



### 实现个v-model    

简版，可自行[百度](https://www.baidu.com/)

```vue
<!-- 父组件 -->
<template>
	<Child v-model="value" />
</template>
<script>
export default {
  data() {
    return {
      value: ''
    }
  }
}
</script>

<!-- 子组件 -->
<template>
	<input v-model="input" />
</template>
<script>
export default {
  props: {
    value: String,
  },
  model: {
    prop: 'value',		// 指定 v-model 要绑定的参数叫什么名字，来自于 props 中定义的参数
    event: 'change',	// 指定要触发的事件名字，将被用于 $emit
  },
  computed: {
    input: {
      // 这里的计算属性使用了 getter、setter，可以简化代码
      get() {
        return this.value;
      },
      set(val) {
        this.$emit('change', val);	// 触发
      }
    }
  }
}
</script>
```





### 输出打印内容(顺序)   

```javascript
setTimeout(() => {
    console.log(2);
    Promise.resolve().then(() => {
        console.log(6);
    });
}, 0);
Promise.resolve(3).then((data) => {
    console.log(data);          
    return data + 1;
}).then((data) => {
    console.log(data)                
    setTimeout(() => {
        console.log(data + 1)        
        return data + 1;
    }, 1000)
}).then((data) => {
    console.log(data);                
});
```



```javascript
setTimeout(() => {
    console.log('A');
}, 0);
var obj = {
    func: function () {
        setTimeout(function () {
            console.log('B')
        }, 0);
        return new Promise(function (resolve) {
            console.log('C');
            resolve();
        })
    }
};
obj.func().then(function () {
    console.log('D')
});
console.log('E');
```



```javascript
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
	console.log('async2');
}

console.log('script start');    

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```



```javascript
var length = 10;
function fn() {
    console.log(this.length);
}
var obj = {
    length: 5,
    method: function () {
        fn();
        arguments[0]();
    }
}
obj.method(fn, 1);
```



```
const b = {name: 'bbbb'}
function A () {
    this.name = 'aaaaa'
	// 如果返回值不是object类型，那就返回{name:'aaa'}，否则返回return中的东西
    return 1
}

const c = new A()

console.log(c);
```



```javascript
(function () {
  var a = (b = 5);
})();

console.log(b);
console.log(a);
```



```javascript
function Person(name) {
    this.name = name;
}
const p = new Person('tantan');
console.log(p.__proto__)
console.log(p.__proto__.__proto__)
console.log(Person.__proto__)
console.log(Person.__proto__.__proto__)
console.log(Person.__proto__.__proto__.__proto__)
```



```javascript
x = "global";
(function() {
    console.log(x)
    let x = 123;
}());
```



```javascript
if([] == false) {
  console.log(1)
}

if({} == false) {
  console.log(2)
}

if([]) {
  console.log(3)
}

if([1] == [1]) {
  console.log(4)
}
```



```javascript
console.log(a);

var a = 12;

function foo() {
  console.log(a);
  var a = 13;
}

foo();

console.log(a);
```



```javascript
console.log(b);

var b = 12;

function bar() {
  console.log(b);
  b = 13;
}

bar();

console.log(b);
```



```javascript
function foo() {
  var i = 10;
  return function (n) {
    console.log(n + ++i);
  };
}

var bar = foo();
bar(10);
bar(20);
foo()(10);
foo()(20);
```



```javascript
function foo() {
  console.log(this.a);
}

var a = 1;

foo();

var obj = {
  a: 2,
  foo: foo,
};

obj.foo();

var c = new foo();

c.a = 3;

console.log(c.a);
```



```javascript
var name = "JS",
  obj = {
    name: "ES",
    prop: {
      getName: function () {
        return this.name;
      },
    },
  };

console.log(obj.prop.getName());

var getName = obj.prop.getName;

console.log(getName());
```





# 非技术相关   

参考我的文章：[【非技术性问题】](https://juejin.cn/post/6844904008335753224)  

